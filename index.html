<!DOCTYPE html>
<html>
<head>
    <title>HVRSN - I Hate Spreadsheets</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin="anonymous"></script>
    <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            overflow: hidden;
            background-color: #f0f2f5; /* Overall app background */
        }
    
        #app-container {
            display: flex;
            width: 100%;
            height: 100%;
        }
    
        /* Glassmorphic Sidebar Style */
        #sidebar {
            width: 360px;
            /* ORIGINAL: background-color: #f0f2f5; */
            background: hsla(220, 15%, 96%, 0.7); /* Light, cool white-ish with transparency */
            backdrop-filter: blur(25px) saturate(150%);
            -webkit-backdrop-filter: blur(25px) saturate(150%);
            padding: 20px; /* Overall padding for sidebar */
            /* ORIGINAL: border-right: 1px solid #d1d1d6; */
            border-right: 1px solid hsla(220, 15%, 85%, 0.5); /* Softer border */
            overflow-y: auto;
            height: 100vh;
            box-sizing: border-box;
            position: relative; /* Added for positioning children absolutely */
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.17); /* Softer, more diffused shadow */
            color: #1d1d1f; /* Default text color for better contrast */
        }
    
        /* Custom Scrollbar for Webkit Browsers (Chrome, Safari, Edge) - More subtle glass style */
        #sidebar::-webkit-scrollbar {
            width: 7px; /* Slightly wider for visibility */
        }
        #sidebar::-webkit-scrollbar-track {
            background: transparent; /* Track is invisible */
            border-radius: 10px;
        }
        #sidebar::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.25); /* Subtle scrollbar thumb */
            border-radius: 10px;
        }
        #sidebar::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.35);
        }
    
        #sidebar h2 {
            margin-top: 0;
            margin-bottom: 20px;
            color: #1d1d1f;
            font-size: 1.7em;
            font-weight: 600;
        }
    
        /* Instructions Toggle Button */
        #toggle-instructions-btn {
            position: absolute;
            top: 22px; /* Align with H2 title */
            right: 20px; /* Respect sidebar padding */
            font-size: 1.6em; /* Icon size */
            cursor: pointer;
            color: #6e6e73;
            z-index: 10;
            transition: color 0.2s;
            line-height: 1; /* Ensure consistent vertical alignment */
        }
        #toggle-instructions-btn:hover {
            color: #007aff;
        }
    
        /* Sidebar Section Base Style - Glassmorphic appearance */
        .sidebar-section {
            /* ORIGINAL: background-color: #ffffff; */
            background: rgba(255, 255, 255, 0.55); /* Whiter, slightly more opaque glass base */
            padding: 16px; /* Adjusted padding for glass sections */
            border-radius: 12px; /* More modern rounding */
            margin-bottom: 20px; /* Consistent spacing */
            /* ORIGINAL: box-shadow: 0 1px 2px rgba(0,0,0,0.03), 0 2px 6px rgba(0,0,0,0.03); */
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.07), 0 1px 3px rgba(0,0,0,0.05); /* Softer shadow */
            border: 1px solid rgba(255, 255, 255, 0.25); /* Subtle border for definition */
        }
    
        /* Ensure display properties remain */
        #mode-selector,
        #search-section,
        #controls-section,
        #profile-selector, /* For Directions */
        #proximity-controls-section, /* For Proximity */
        #location-list-container,
        #external-partner-list-container,
        #station-list-container
         {
            /* Common section styling applied */
        }
    
         #proximity-controls-section label,
         #proximity-controls-section input,
         #proximity-controls-section select {
            display: block;
            margin-bottom: 8px;
            width: 100%;
            box-sizing: border-box;
         }
         /* Input/select styles in proximity section - overridden below by general glass styles */
         #proximity-controls-section input[type="number"],
         #proximity-controls-section select {
            /* ORIGINAL: padding: 8px 10px; */
            /* ORIGINAL: border: 1px solid #d1d1d6; */
            /* ORIGINAL: border-radius: 5px; */
            /* ORIGINAL: font-size: 0.9em; */
         }
         #proximity-controls-section label {
             margin-bottom: 4px;
             font-size: 0.85em; /* Adjusted below */
             /* ORIGINAL: color: #333; */
             font-weight: 500; /* Adjusted below */
         }
    
    
        /* Instructions section - specific glass styling */
        #instructions.sidebar-section { /* Apply glass style to instructions section too */
            color: #333333;
            font-size: 0.9em;
            line-height: 1.5;
            display: none; /* Initially hidden */
            /* ORIGINAL: background-color: #eef7ff; */
            background: rgba(230, 240, 255, 0.75); /* Light blue, glassy */
            border-color: rgba(200, 220, 255, 0.6);
            padding: 16px; /* Match other sections */
            border-radius: 12px;
            margin-bottom: 20px;
        }
        #instructions p { margin-top: 0; margin-bottom: 8px; }
        #instructions p:last-child { margin-bottom: 0; }
    
    
        #profile-selector { display: none; } /* For Directions */
        #proximity-controls-section { display: none; } /* For Proximity */
    
    
        /* Styles for Profile and Controls labels (not the mode selector ones) */
        #profile-selector label,
        #controls-section label {
            /* ORIGINAL: margin-right: 10px; */
            display: inline-flex;
            align-items: center;
            font-size: 0.9em; /* Slightly smaller consistent with other elements */
            color: #2c2c2e; /* Dark text for readability */
            cursor: pointer;
            position: relative;
        }
    
        #controls-section label {
            display: flex; /* Use flex for checkbox alignment */
            margin-bottom: 10px;
            padding: 4px 0; /* Add some vertical padding */
        }
        #controls-section label:last-child { margin-bottom: 0; }
    
        /* Styles for Radio/Checkbox inputs (Profile and Controls) */
        #profile-selector input[type="radio"],
        #controls-section input[type="checkbox"] {
            margin-right: 10px; /* More space */
            accent-color: #007aff;
            transform: scale(1.15); /* Slightly larger */
            cursor: pointer;
            flex-shrink: 0; /* Prevent checkbox from shrinking */
        }
    
        /* Section Titles - Glassmorphic style */
        #search-section h3,
        #profile-selector h3,
        #proximity-controls-section h3,
        #location-list-container h3,
        #external-partner-list-container h3,
        #station-list-container h3,
        #controls-section h3 {
            margin-top: 0;
            margin-bottom: 14px; /* More space below title */
            font-size: 0.9em; /* Slightly larger section titles */
            font-weight: 600;
            color: #3a3a3c; /* Slightly darker and less saturated than default #6e6e73 for better legibility on glass */
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
    
        /* Search Input, Results, and Map Click Button Styling */
        /* Search Input Style - Glassmorphic appearance */
        #search-input {
            width: 100%;
            padding: 9px 12px; /* Adjusted padding */
            margin-bottom: 10px;
            /* ORIGINAL: border: 1px solid #d1d1d6; */
            border: 1px solid rgba(200, 200, 205, 0.5); /* Lighter border */
            border-radius: 8px; /* Consistent rounding */
            box-sizing: border-box;
            font-size: 0.9em; /* Slightly smaller */
            /* ORIGINAL: background-color: #f9f9f9; */
            background-color: rgba(255, 255, 255, 0.4); /* Glassy input background */
            color: #1d1d1f; /* Ensure text is dark and readable */
        }
        /* Search Input Focus Style - Glassmorphic focus ring */
        #search-input:focus {
            /* ORIGINAL: border-color: #007aff; */
            border-color: #007aff; /* Accent color for focus */
            outline: none; /* Remove default blue outline */
            /* ORIGINAL: background-color: #ffffff; */
            background-color: rgba(255, 255, 255, 0.7); /* More opaque on focus */
            /* ORIGINAL: box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.2); */
            box-shadow: 0 0 0 2.5px rgba(0, 122, 255, 0.2); /* Softer, modern focus ring */
        }
    
        #search-results-container {
            max-height: 180px; /* Limit height of results */
            overflow-y: auto;
            border-radius: 7px;
            background-color: #ffffff; /* Keep white background for results list */
        }
        #search-results-list {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        #search-results-list li {
            padding: 10px 14px;
            cursor: pointer;
            font-size: 0.9em;
            color: #1d1d1f;
            border-bottom: 1px solid #f0f2f5; /* Subtle separator */
            transition: background-color 0.15s ease;
        }
        #search-results-list li:last-child { border-bottom: none; }
        #search-results-list li:hover { background-color: #e9e9f0; } /* Subtle hover */
    
        /* Style for the map click button - Glassmorphic style */
        .map-click-button { /* Shared by toggle-map-click-mode and run-proximity-analysis */
            width: 100%;
            box-sizing: border-box;
            padding: 9px 12px; /* Adjusted padding */
            margin-top: 10px;
            /* ORIGINAL: border: 1px solid #007aff; */
            border: 1.5px solid #007aff; /* Slightly thicker border */
            border-radius: 9px; /* Consistent rounding */
            /* ORIGINAL: background-color: #f0f2f5; */
            background-color: rgba(0, 122, 255, 0.1); /* Light glassy base */
            color: #007aff;
            font-size: 0.88em; /* Slightly smaller */
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            text-align: center;
        }
        .map-click-button:hover {
            /* ORIGINAL: background-color: #e9f5ff; */
            background-color: rgba(0, 122, 255, 0.15); /* Lighter hover for outline style */
            border-color: #005bb5;
        }
        .map-click-button.active { /* For toggle-map-click-mode */
            background-color: #007aff; /* Solid active state for clarity */
            color: white;
            border-color: #005bb5;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
        }
        .map-click-button.active:hover {
            background-color: #005bb5;
        }
    
    
        /* Scrollbar for search results (WebKit) */
        #search-results-container::-webkit-scrollbar { width: 5px; }
        #search-results-container::-webkit-scrollbar-track { background: transparent; }
        #search-results-container::-webkit-scrollbar-thumb { background: #c1c1c7; border-radius: 3px;}
        #search-results-container::-webkit-scrollbar-thumb:hover { background: #a8a8ae; }
    
        /* Reset button style - Glassmorphic appearance */
        #reset-selection {
            display: block;
            width: 100%;
            box-sizing: border-box;
            padding: 11px 18px; /* Adjusted padding */
            margin-bottom: 20px; /* Consistent spacing */
            /* ORIGINAL: background-color: #2d93ff; */
            background-color: rgba(0, 122, 255, 0.75); /* Primary action, glassy */
            color: white;
            border: 1px solid transparent; /* Can be transparent if bg is strong, or match accent */
            border-radius: 9px; /* Consistent rounding */
            font-weight: 500;
            font-size: 0.9em; /* Slightly smaller */
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            text-align: center;
            /* ORIGINAL: box-shadow: none; */
             box-shadow: 0 3px 8px rgba(0, 122, 255, 0.25), 0 1px 2px rgba(0,0,0,0.05);
        }
        #reset-selection:hover {
            /* ORIGINAL: background-color: #005bb5; */
             background-color: rgba(0, 110, 230, 0.85);
             box-shadow: 0 4px 12px rgba(0, 122, 255, 0.35), 0 2px 4px rgba(0,0,0,0.07);
             transform: translateY(-1px);
        }
    
        /* Combined list styling for all types */
        #location-list, #external-partner-list, #station-list, #proximity-results-list { list-style-type: none; padding: 0px; margin: 0; }
        #location-list li, #external-partner-list li, #station-list li, #proximity-results-list li {
            padding: 10px 14px 10px 38px; /* Adjusted padding-left to make space for the icon/emoji, slightly less vertical */
            cursor: pointer;
            transition: background-color 0.15s ease, color 0.15s ease;
            font-size: 0.92em; /* Slightly smaller text */
            color: #1d1d1f;
            border-radius: 7px;
            margin-bottom: 4px;
            position: relative;
        }
        #proximity-results-list li { cursor: default; } /* Results are not clickable to re-select */
    
        #location-list li::before,
        #external-partner-list li::before,
        #station-list li::before {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            transition: color 0.15s ease; /* Keep transition for color-based icons */
        }
    
        /* Icons for each type (in the list) */
        #location-list li.location-item::before {
            content: ''; /* Change from emoji to empty content for background image */
            width: 20px; /* Size of the image container */
            height: 20px; /* Size of the image container */
            background-image: url('images/bluemarker.png'); /* Path to your blue marker image */
            background-size: contain; /* Make the image fit */
            background-repeat: no-repeat;
            background-position: center;
        }
        #external-partner-list li.location-item::before {
             content: '📌';
             font-size: 1em; /* Slightly smaller emoji */
             color: #8e8e93; /* Keep default color for emojis */
        }
        #station-list li.station-item::before {
            content: '🚂';
            font-size: 1em; /* Slightly smaller emoji */
            color: #8e8e93; /* Keep default color for emojis */
        }
         #proximity-results-list li::before { /* Specific rule for proximity results checkmark */
             content: '✔️';
             position: absolute; /* Ensure positioning */
             left: 12px;
             top: 50%;
             transform: translateY(-50%);
             color: #007aff; /* Color of the checkmark */
             font-size: 1em; /* Adjust size if needed */
         }
    
        #location-list li:last-child,
        #external-partner-list li:last-child,
        #station-list li:last-child,
        #proximity-results-list li:last-child { margin-bottom: 0; }
    
        #location-list li:hover,
        #external-partner-list li:hover,
        #station-list li:hover { background-color: #e9e9f0; }
    
        /* Hover effect for emoji icons (Digipunten now use image, won't be affected by color change) */
        li:not([class*="selected-"]):hover::before {
             color: #2289f7;
        }
    
        /* Selection styling */
        li[data-id].selected-haversine,
        li[data-id].selected-directions-start,
        li[data-id].selected-directions-end,
        li[data-id].selected-proximity-center { /* Added for proximity center */
             color: white; font-weight: 500;
        }
        li[data-id].selected-haversine::before,
        li[data-id].selected-directions-start::before,
        li[data-id].selected-directions-end::before,
        li[data-id].selected-proximity-center::before { /* Added for proximity center */
            color: white; /* Keep for emoji types */
        }
        li[data-id].selected-haversine { background-color: #56a8ff; }
        li[data-id].selected-directions-start { background-color: #56a8ff; }
        li[data-id].selected-directions-end { background-color: #67e186; }
        li[data-id].selected-proximity-center { background-color: #ff9500; } /* Orange for proximity center */
    
    
        #map-container { flex-grow: 1; height: 100vh; }
    
        .info-panel {
            margin-bottom: 20px; padding: 16px; display: none; /* Match section padding and margin */
            /* ORIGINAL: background-color: #ffffff; */
            background: rgba(255, 255, 255, 0.55); /* Glassy info panel */
            border-radius: 12px; /* Match section rounding */
            /* ORIGINAL: box-shadow: 0 1px 2px rgba(0,0,0,0.03), 0 2px 6px rgba(0,0,0,0.03); */
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.07), 0 1px 3px rgba(0,0,0,0.05); /* Softer shadow */
            border: 1px solid rgba(255, 255, 255, 0.25); /* Subtle border */
        }
        #sidebar > .info-panel:last-of-type { margin-bottom: 0; }
        .info-panel h3 { font-size: 1em; font-weight: 600; color: #1d1d1f; margin-top: 0; margin-bottom: 15px; }
        .info-panel ul, .info-panel div { font-size: 0.92em; list-style-type: none; padding: 0; color: #333333; }
        .info-panel li { padding: 6px 0; border-bottom: 1px solid #f0f2f5; }
        .info-panel li:last-child { border-bottom: none; }
        .info-panel .error-message, .info-panel .loading-message { font-style: normal; padding: 5px 0; }
        .info-panel .error-message { color: #ff3b30; font-weight: 500; }
        .info-panel .loading-message { color: #555555; }
        #selected-location-name-haversine { font-weight: 600; color: #007aff; }
        #selected-location-name-directions-start { font-weight: 600; color: #4da1fa; }
        #selected-location-name-directions-end { font-weight: 600; color: #55c671; }
        #proximity-center-name { font-weight: 600; color: #ff9500; } /* Orange for proximity */
        #proximity-parameters-display { font-size: 0.85em; color: #6e6e73; margin-bottom: 10px; }
    
    
        .custom-popup .leaflet-popup-content-wrapper {
            background: #ffffff; border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            padding: 0; border: 0.5px solid rgba(0,0,0,0.08);
        }
        .custom-popup .leaflet-popup-content {
            margin: 0; padding: 12px 15px;
            font-size: 13px;
            line-height: 1.45;
            color: #1d1d1f;
            max-height: 320px; /* Increased max-height for images and opening hours */
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        .custom-popup .leaflet-popup-content strong { font-weight: 600; color: #000000; }
        .custom-popup .leaflet-popup-content em { font-style: italic; color: #555; font-size: 0.9em; }
        .custom-popup .leaflet-popup-content .hours-block { margin-top: 8px; font-size: 0.9em; line-height: 1.5; }
        .custom-popup .leaflet-popup-content .hours-block br { margin-bottom: 2px; }
        .custom-popup .leaflet-popup-content .popup-image {
            width: 100%;
            max-height: 100px; /* Adjust as needed, ensuring total popup content fits 300px */
            object-fit: cover;
            border-radius: 4px;
            margin-top: 8px;
            margin-bottom: 8px;
        }
    
        .custom-popup .leaflet-popup-tip { background: #ffffff; border: 0.5px solid rgba(0,0,0,0.08); box-shadow: none; }
        .custom-popup a.leaflet-popup-close-button {
            position: absolute; top: 8px; right: 10px; padding: 0; width: 24px; height: 24px;
            font-size: 22px; line-height: 24px; color: #b0b0b5; text-align: center;
            text-decoration: none; font-weight: normal; background: transparent;
            border-radius: 50%; transition: color 0.2s ease, background-color 0.2s ease;
        }
        .custom-popup a.leaflet-popup-close-button:hover { color: #1d1d1f; background-color: rgba(0,0,0,0.05); }
    
        .leaflet-div-icon { background: none; border: none; }
        .station-emoji-marker, .external-partner-emoji-marker {
            display: flex; align-items: center; justify-content: center;
            font-size: 30px; text-shadow: 0 0 3px rgba(0,0,0,0.3);
            width: 36px !important; height: 36px !important;
        }
    
        /* Mode Selector Grid Style */
        #mode-selector {
            display: grid; /* Use grid layout */
            grid-template-columns: 1fr 1fr; /* Create two columns of equal width */
            gap: 10px 20px; /* Add space between rows (10px) and columns (20px) */
            /* Inherits glassmorphic styles from .sidebar-section */
            padding: 12px; /* Less padding if buttons take up space */
            /* ORIGINAL: margin-bottom: 18px; */
            margin-bottom: 20px; /* Consistent spacing */
        }
    
        /* Hide the actual radio dot for mode selector */
        #mode-selector input[type="radio"] {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
            pointer-events: none; /* Prevent any interaction */
        }
    
        /* Style the labels in mode selector as glass buttons */
        #mode-selector label {
            margin-right: 0; /* Remove original margin as grid handles spacing */
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative; /* Keep for pseudo-elements if needed later */
            cursor: pointer;
    
            /* Button Styling */
            padding: 10px 8px; /* Adjust padding; grid provides horizontal spacing via 'gap' */
            border-radius: 9px;
            font-size: 0.88em; /* Slightly smaller for dense layout */
            font-weight: 500; /* Medium weight for button text */
            text-align: center;
            color: #2c2c2e; /* Dark text for readability */
    
            /* Glass Effect for Label-Buttons */
            background: rgba(255, 255, 255, 0.3); /* Base glass for buttons */
            border: 1px solid rgba(255, 255, 255, 0.4);
            box-shadow: 0 1px 2px rgba(0,0,0,0.04), 0 2px 4px rgba(0,0,0,0.04);
    
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1); /* Standard material-like transition */
        }
    
        #mode-selector label:hover {
            background: rgba(255, 255, 255, 0.5);
            border-color: rgba(255, 255, 255, 0.6);
            transform: translateY(-1px); /* Subtle lift */
            box-shadow: 0 2px 4px rgba(0,0,0,0.06), 0 4px 8px rgba(0,0,0,0.06);
            color: #000;
        }
    
        /* STYLING FOR CHECKED STATE (ACTIVATED BUTTON) using :has() */
        /* Requires modern browser support for :has() */
        #mode-selector label:has(input[type="radio"]:checked) {
            background: #beddfe; /* Primary accent color, more solid for active state */
            color: black;
            font-weight: 600; /* Bolder text for active state */
            border-color: rgba(50, 127, 209, 0.7);
            box-shadow: 0 0 0 1.5px rgba(0, 122, 255, 0.6), /* Outline effect */
                        inset 0 1px 2px rgba(0, 0, 0, 0.2); /* Inner shadow for pressed feel */
            transform: translateY(0.5px) scale(0.97); /* Slight press effect */
        }
    
        /* Focus state for accessibility (also uses :has()) */
         #mode-selector label:has(input[type="radio"]:focus-visible) {
            outline: 2px solid #007FFF;
            outline-offset: 3px;
            border-color: rgba(0,122,255,0.7); /* Ensure border also indicates focus */
        }
    
    
        /* Update input fields and selects for consistency (glassmorphic) */
        #sidebar input[type="text"],
        #sidebar input[type="number"],
        #sidebar select {
            /* ORIGINAL values commented/overridden above */
            background-color: rgba(255, 255, 255, 0.4); /* Glassy input background */
            border: 1px solid rgba(200, 200, 205, 0.5); /* Lighter border */
            color: #1d1d1f; /* Ensure text is dark and readable */
            border-radius: 8px; /* Consistent rounding */
            padding: 9px 12px; /* Adjust padding for sleekness */
            font-size: 0.9em;
        }
    
        #sidebar input[type="text"]:focus,
        #sidebar input[type="number"]:focus,
        #sidebar select:focus {
            /* ORIGINAL values commented/overridden above */
            border-color: #007aff; /* Accent color for focus */
            outline: none; /* Remove default blue outline */
            background-color: rgba(255, 255, 255, 0.7); /* More opaque on focus */
            box-shadow: 0 0 0 2.5px rgba(0, 122, 255, 0.2); /* Softer, modern focus ring */
        }
    
         /* Specific adjustment for proximity section labels (make slightly darker like titles) */
         #proximity-controls-section label {
            color: #3a3a3c;
            font-weight: 600;
            font-size: 0.9em; /* Match other labels/inputs */
         }
    
    
        /* Update main action button (#reset-selection) for consistency (glassmorphic) */
        #reset-selection {
            /* ORIGINAL values commented/overridden above */
            background-color: rgba(0, 122, 255, 0.75); /* Primary action, glassy */
            color: white;
            border: 1px solid transparent;
            box-shadow: 0 3px 8px rgba(0, 122, 255, 0.25), 0 1px 2px rgba(0,0,0,0.05);
            font-weight: 500;
            padding: 11px 18px; /* Adjust padding */
            border-radius: 9px;
            font-size: 0.9em; /* Slightly smaller */
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            text-align: center;
            margin-bottom: 20px; /* Consistent spacing */
        }
    
        #reset-selection:hover {
            /* ORIGINAL values commented/overridden above */
             background-color: rgba(0, 110, 230, 0.85);
             box-shadow: 0 4px 12px rgba(0, 122, 255, 0.35), 0 2px 4px rgba(0,0,0,0.07);
             transform: translateY(-1px);
        }
    
        /* Style for map click buttons for consistency (glassmorphic) */
        .map-click-button {
            /* ORIGINAL values commented/overridden above */
            border-radius: 9px;
            padding: 9px 12px;
            font-weight: 500;
            font-size: 0.88em;
            border: 1.5px solid #007aff;
            background-color: rgba(0, 122, 255, 0.1); /* Light glassy base */
            color: #007aff;
            transition: all 0.2s ease-in-out;
            text-align: center;
             margin-top: 10px;
             width: 100%;
             box-sizing: border-box;
        }
        .map-click-button:hover {
            /* ORIGINAL values commented/overridden above */
            background-color: rgba(0, 122, 255, 0.15); /* Lighter hover for outline style */
            border-color: #005bb5;
        }
        .map-click-button.active {
            /* ORIGINAL values commented/overridden above */
            background-color: #007aff; /* Solid active state for clarity */
            color: white;
            border-color: #005bb5;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
        }
        .map-click-button.active:hover {
            background-color: #005bb5;
        }
    
        /* Section Titles - Ensure they are clearly visible on the glassy background */
        #search-section h3,
        #profile-selector h3,
        #proximity-controls-section h3,
        #location-list-container h3,
        #external-partner-list-container h3,
        #station-list-container h3,
        #controls-section h3 {
            /* ORIGINAL values commented/overridden above */
            color: #3a3a3c; /* Slightly darker and less saturated */
            font-weight: 600;
            margin-bottom: 14px;
            font-size: 0.9em; /* Slightly larger */
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
    
        /* Checkbox and its label alignment in #controls-section */
        #controls-section input[type="checkbox"] {
            margin-right: 10px; /* More space */
            transform: scale(1.15); /* Slightly larger */
            accent-color: #007aff; /* Keep accent */
            flex-shrink: 0; /* Prevent checkbox from shrinking */
        }
        #controls-section label {
            display: flex; /* Use flex for better alignment of checkbox and text */
            align-items: center;
            padding: 4px 0; /* Add some vertical padding */
            font-size: 0.9em;
            color: #2c2c2e; /* Darker text for controls */
            /* ORIGINAL: margin-bottom handled by .sidebar-section > label rule */
        }
         #controls-section label:last-child { margin-bottom: 0; }
    
    
    </style>
</head>
<body>
    <div id="app-container">
        <div id="sidebar">
            <span id="toggle-instructions-btn" title="Toon/Verberg Instructies">💡</span>
            <h2 id="app-title">🗺️ Kaartweergave</h2> <!-- Default title updated -->

        <div id="mode-selector" class="sidebar-section">
            <label><input type="radio" name="mode" value="kaartweergave" checked> Kaartweergave</label> <!-- New mode, default -->
            <label><input type="radio" name="mode" value="haversine"> Alle Afstanden</label>
            <label><input type="radio" name="mode" value="directions"> Bereken Route</label>
            <label><input type="radio" name="mode" value="proximity"> In De Buurt</label>
        </div>

        <div id="controls-section" class="sidebar-section">
             <h3>Weergave Opties</h3>
             <label><input type="checkbox" id="show-all-popups-toggle"> Toon alle locatie data op kaart</label>
             <label><input type="checkbox" id="show-digipunten-toggle" checked> Inclusief alle Digipunten</label>
             <label><input type="checkbox" id="show-external-partners-toggle"> Inclusief Externe Partners</label>
             <label><input type="checkbox" id="show-stations-toggle"> Inclusief alle Treinstations</label>
        </div>

        <div id="profile-selector" class="sidebar-section"> <!-- For Directions mode -->
             <h3>Route Type:</h3>
             <label><input type="radio" name="profile" value="driving-car" checked> Auto</label>
             <label><input type="radio" name="profile" value="cycling-regular"> Fiets</label>
             <label><input type="radio" name="profile" value="foot-walking"> Voetganger</label>
        </div>

        <div id="proximity-controls-section" class="sidebar-section"> <!-- For Proximity mode -->
            <h3>Nabijheidsanalyse Instellingen</h3>
            <div>
                <label for="proximity-type">Analyse Type:</label>
                <select id="proximity-type">
                    <option value="distance" selected>Afstand (km)</option>
                    <option value="time">Reistijd (min)</option>
                </select>
            </div>
            <div id="proximity-distance-controls-group">
                <label for="proximity-radius">Radius (km):</label>
                <input type="number" id="proximity-radius" value="2" min="0.1" step="0.1">
            </div>
            <div id="proximity-time-controls-group" style="display: none;">
                <label for="proximity-time">Reistijd (min):</label>
                <input type="number" id="proximity-time" value="15" min="1" step="1">
                <label for="proximity-profile">Reisprofiel:</label>
                <select id="proximity-profile">
                    <option value="foot-walking" selected>Voetganger</option>
                    <option value="cycling-regular">Fiets</option>
                    <option value="driving-car">Auto</option>
                </select>
            </div>
            <button id="run-proximity-analysis" class="map-click-button" style="margin-top: 15px;">Vind Nabije Locaties</button>
        </div>


        <div id="instructions" class="sidebar-section"></div>

        <button id="reset-selection">Selectie Herstellen</button>

        <div id="search-section" class="sidebar-section">
            <h3>Zoek Specifieke Locatie</h3>
            <input type="text" id="search-input" placeholder="Voer adres, plaatsnaam of halte in...">
            <div id="search-results-container">
                <ul id="search-results-list"></ul>
            </div>
            <button id="toggle-map-click-mode" class="map-click-button">Pinpunt Locatie op Kaart</button>
        </div>

        <div id="location-list-container" class="sidebar-section">
             <h3>Digipunten</h3>
             <ul id="location-list"></ul>
        </div>
        <div id="external-partner-list-container" class="sidebar-section">
             <h3>Externe Partners</h3>
             <ul id="external-partner-list"></ul>
        </div>
        <div id="station-list-container" class="sidebar-section">
             <h3>Treinstations</h3>
             <ul id="station-list"></ul>
        </div>

        <div id="haversine-info" class="info-panel">
            <h3>Afstanden vanaf <span id="selected-location-name-haversine">nvt</span>:</h3>
            <ul id="haversine-distance-list"></ul>
        </div>
        <div id="directions-info" class="info-panel">
            <h3>Route Details (<span id="current-profile-display">Auto</span>):</h3>
            <div id="directions-route-summary"></div>
        </div>
        <div id="proximity-info" class="info-panel"> <!-- For Proximity Results -->
            <h3>Locaties Nabij <span id="proximity-center-name">nvt</span></h3>
            <div id="proximity-parameters-display"></div>
            <div id="proximity-status-message" class="loading-message" style="display: none;"></div>
            <ul id="proximity-results-list"></ul>
        </div>
    </div>
    <div id="map-container"></div>
</div>

<script>
    // --- YOUR OPENROUTESERVICE API KEY ---
    const ORS_API_KEY = "5b3ce3597851110001cf624809966b681b2a4525b72dba6838e2e32e"; // REPLACE THIS WITH YOUR ACTUAL KEY
    // --- END CONFIGURATION ---

    // Data for Digipunt details (address, opening hours) - REVISED STRUCTURE
    const digipuntDetailsData = [
        { idToMatch: "vlaamsekaai", address: "Vlaamsekaai 10", hours: ["Maandag: 09u00 - 17u00", "Dinsdag: 09u00 - 17u00", "Woensdag: 13u00 - 17u00", "Donderdag: Gesloten", "Vrijdag: Gesloten"], break: { start: "12u00", end: "13u00" } }, // Assumed 12-13 break on Mon/Tue
        { idToMatch: "uco", address: "Getouwstraat 5", hours: ["Maandag: 09u00 - 17u00", "Dinsdag: 09u00 - 17u00", "Woensdag: Gesloten", "Donderdag: 09u00 - 17u00", "Vrijdag: 09u00 - 17u00"], break: { start: "12u00", end: "13u00" } }, // Assumed 12-13 break on Mon/Tue/Thu/Fri
        { idToMatch: "rabot", address: "Griendeplein 16", hours: ["Maandag: 09u00 - 12u00", "Dinsdag: 09u00 - 12u00", "Woensdag: Gesloten", "Donderdag: 09u00 - 12u00", "Vrijdag: 09u00 - 12u00"] }, // Morning only, no break property
        { idToMatch: "deserre", address: "Rerum Novarumplein 10", hours: ["Maandag: Gesloten", "Dinsdag: 13u00 - 16u00", "Woensdag: Gesloten", "Donderdag: Gesloten", "Vrijdag: 13u00 - 17u00"] }, // Afternoon only, no break property
        { idToMatch: "brugsesteenweg", address: "Brugsesteenweg 354", hours: ["Maandag: Gesloten", "Dinsdag: 09u00 - 17u00", "Woensdag: Gesloten", "Donderdag: 09u00 - 17u00", "Vrijdag: Gesloten"], break: { start: "12u00", end: "13u00" } }, // Assumed 12-13 break on Tue/Thu
        { idToMatch: "amal", address: "Kongostraat 42", hours: ["Maandag: 09u00 - 17u00", "Dinsdag: Gesloten", "Woensdag: Gesloten", "Donderdag: 09u00 - 17u00", "Vrijdag: 09u00 - 17u00"], break: { start: "12u00", end: "13u00" } }, // Assumed 12-13 break on Mon/Thu/Fri
        { idToMatch: "scheldeoord", address: "Wolterslaan 16", hours: ["Maandag: 13u00-17u00", "Dinsdag: Gesloten", "Woensdag: Gesloten", "Donderdag: Gesloten", "Vrijdag: Gesloten"] }, // Afternoon only, no break property
        { idToMatch: "eetcafe", address: "Vlotstraat 22", hours: ["Maandag: 13u00 - 16u00", "Dinsdag: Gesloten", "Woensdag: Gesloten", "Donderdag: 13u00 - 17u00", "Vrijdag: Gesloten"] }, // Afternoon only, no break property
        { idToMatch: "jobteam", address: "Doornakkerstraat 52", hours: ["Maandag: Gesloten", "Dinsdag: Gesloten", "Woensdag: Gesloten", "Donderdag: 13u30 - 17u00", "Vrijdag: 09u00 - 12u00"] }, // Mixed, no single consistent full-day break pattern, no break property
        { idToMatch: "wgcsintamandsberg", address: "Sporewegel 3", hours: ["Maandag: Gesloten", "Dinsdag: 13u30 - 17u00", "Woensdag: Gesloten", "Donderdag: 09u00 - 12u00", "Vrijdag: Gesloten"] }, // Mixed, no single consistent full-day break pattern, no break property
        { idToMatch: "bibwatersportbaan", address: "Neermeerskaai 1b", hours: ["Maandag: Gesloten", "Dinsdag: Gesloten", "Woensdag: 14u00 - 17u00", "Donderdag: Gesloten", "Vrijdag: Gesloten"] }, // Single afternoon session, no break property
        { idToMatch: "bibbrugsepoort", address: "Blazoenstraat 9", hours: ["Maandag: Gesloten", "Dinsdag: Gesloten", "Woensdag: 14u00 - 17u00", "Donderdag: Gesloten", "Vrijdag: Gesloten"] }, // Single afternoon session, no break property
        { idToMatch: "bibsintamandsberg", address: "Halvemaanstraat 92", hours: ["Maandag: Gesloten", "Dinsdag: Gesloten", "Woensdag: 14u00 - 17u00", "Donderdag: Gesloten", "Vrijdag: Gesloten"] }, // Single afternoon session, no break property
        { idToMatch: "stadskantoor", address: "Woodrow Wilsonplein 1", hours: ["Maandag: 09u00 - 16u30", "Dinsdag: 09u00 - 16u30", "Woensdag: 09u00 - 16u30", "Donderdag: 09u00 - 16u30", "Vrijdag: 09u00 - 16u30"], break: { start: "12u30", end: "13u30" } } // 12:30-13:30 break
    ];

    // Locations are the "Digipunten", now with image paths
    const locations = [
        { id: 'amal', title: 'AMAL', location: { lat: 51.0606253, lng: 3.7319163 }, image: "images/amal.jpg" },
        { id: 'bibbrugsepoort', title: 'Wijkbibliotheek Brugse Poort', location: { lat: 51.0625967, lng: 3.6971764 }, image: "images/brugsepoort.jpg" },
        { id: 'bibsintamandsberg', title: 'Wijkbibliotheek Sint-Amandsberg', location: { lat: 51.0616959, lng: 3.7453856 }, image: "images/bibsa.jpg" },
        { id: 'bibwatersportbaan', title: 'Wijkbibliotheek Watersportbaan', location: { lat: 51.0437767, lng: 3.7080733 }, image: "images/bibwsb.jpg" },
        { id: 'brugsesteenweg', title: 'Kringwinkel Brugsesteenweg', location: { lat: 51.0686483, lng: 3.6858181 }, image: "images/brugsesteenweg.jpg" },
        { id: 'deserre', title: 'De Serre', location: { lat: 51.0236304, lng: 3.7194702 }, image: "images/deserre.jpg" },
        { id: 'eetcafe', title: 'Eetcafé Toreke', location: { lat: 51.0633212, lng: 3.7118666 }, image: "images/toreke.jpeg" },
        { id: 'jobteam', title: 'Jobteam', location: { lat: 51.0544096, lng: 3.7485595 }, image: "images/jobteam.jpg" },
        { id: 'rabot', title: 'Wijkkantoor Rabot', location: { lat: 51.0601875, lng: 3.711071 }, image: "images/wkrabot.jpg" },
        { id: 'scheldeoord', title: 'Scheldeoord', location: { lat: 51.0494794, lng: 3.7459217 }, image: "images/scheldeoord.jpg" },
        { id: 'stadskantoor', title: 'Stadskantoor', location: { lat: 51.0472122, lng: 3.73093 }, image: "images/stadskantoor.png" },
        { id: 'uco', title: 'Kringwinkel UCO', location: { lat: 51.071849, lng: 3.7140459 }, image: "images/uco.jpg" },
        { id: 'vlaamsekaai', title: 'Kringwinkel Vlaamse Kaai', location: { lat: 51.044070, lng: 3.741510 }, image: "images/vlaamsekaai.jpg" },
        { id: 'wgcsintamandsberg', title: 'WGC Sint-Amandsberg', location: { lat: 51.0521143, lng: 3.74279 }, image: "images/wgc.jpg" }
    ];


    // Augment locations with details
    locations.forEach(loc => {
      const detail = digipuntDetailsData.find(d => d.idToMatch === loc.id);
      if (detail) {
        loc.address = detail.address;
        // Copy the modified hours structure and the break property
        loc.hours = detail.hours;
        loc.break = detail.break; // Copy break if it exists
      }
    });

    const trainStations = [
        { id: 'stationdampoort', title: 'Station Dampoort', location: { lat: 51.0558422, lng: 3.7404701 } },
        { id: 'stationsintpieters', title: 'Station Gent-Sint-Pieters', location: { lat: 51.0360946, lng: 3.7108049 } }
    ];
    const externalPartners = [
         {
            id: 'dekrook',
            title: 'Bibliotheek De Krook',
            location: { lat: 51.049086, lng: 3.7288502 },
            address: "Miriam Makebaplein 1",
            hours: [
                "Maandag: 10u00 - 17u00",
                "Dinsdag: 10u00 - 17u00",
                "Woensdag: 10u00 - 17u00",
                "Donderdag: 10u00 - 17u00",
                "Vrijdag: 10u00 - 17u00",
                "Zaterdag: 10u00 - 17u00"
            ],
            break: { start: "12u00", end: "13u00" }, // Assuming 12-13 break on these days
            image: "images/dekrook.jpg" // Added image for De Krook
         }
    ];

    const allLocations = [...locations, ...externalPartners, ...trainStations];

    let map;
    const mapMarkers = {}; // For predefined locations
    let drawnHaversinePolylines = [];
    let drawnDirectionsRoutePolyline = null;
    let drawnProximityShape = null;

    let currentMode = 'kaartweergave'; // Default mode

    // Data for selected points
    let haversineSelectedLocation = null;
    let directionsStartLocation = null;
    let directionsEndLocation = null;
    let proximityCenterLocation = null;

    // Markers for custom (searched/map-clicked) points when they are "committed"
    let customHaversineMarker = null;
    let customDirectionsStartPtMarker = null;
    let customDirectionsEndPtMarker = null;
    let customProximityCenterPtMarker = null;


    let selectedRouteProfile = 'driving-car';
    let showAllPopups = false;
    let showDigipunten = true;
    let showExternalPartners = false;
    let showStations = false;

    let activeSearchedLocation = null; // Data for the current (transient) search/map-click result
    let searchedLocationMarker = null; // Marker for the current (transient) search/map-click result
    const GHENT_FOCUS_POINT = { lat: 51.05, lng: 3.71667 };
    let isMapClickModeActive = false;

    let proximityAnalysisType = 'distance';
    let proximityRadiusKm = 2;
    let proximityTimeMinutes = 15;
    let proximityTravelProfile = 'foot-walking';
    const proximityResults = [];


    const appTitleEl = document.getElementById('app-title');
    const locationListEl = document.getElementById('location-list');
    const stationListEl = document.getElementById('station-list');
    const externalPartnerListEl = document.getElementById('external-partner-list');
    const instructionsEl = document.getElementById('instructions');
    const resetButton = document.getElementById('reset-selection');

    const haversineInfoDiv = document.getElementById('haversine-info');
    const haversineDistanceListEl = document.getElementById('haversine-distance-list');
    const selectedLocationNameHaversineEl = document.getElementById('selected-location-name-haversine');

    const directionsInfoDiv = document.getElementById('directions-info');
    const directionsRouteSummaryEl = document.getElementById('directions-route-summary');
    const profileSelectorDiv = document.getElementById('profile-selector');
    const currentProfileDisplayEl = document.getElementById('current-profile-display');

    const proximityControlsSection = document.getElementById('proximity-controls-section');
    const proximityTypeSelect = document.getElementById('proximity-type');
    const proximityDistanceControlsGroup = document.getElementById('proximity-distance-controls-group');
    const proximityTimeControlsGroup = document.getElementById('proximity-time-controls-group');
    const proximityRadiusInput = document.getElementById('proximity-radius');
    const proximityTimeInput = document.getElementById('proximity-time');
    const proximityProfileSelect = document.getElementById('proximity-profile');
    const runProximityAnalysisButton = document.getElementById('run-proximity-analysis');
    const proximityInfoDiv = document.getElementById('proximity-info');
    const proximityCenterNameEl = document.getElementById('proximity-center-name');
    const proximityParametersDisplayEl = document.getElementById('proximity-parameters-display');
    const proximityStatusMessageEl = document.getElementById('proximity-status-message');
    const proximityResultsListEl = document.getElementById('proximity-results-list');


    const modeRadioButtons = document.querySelectorAll('input[name="mode"]');
    const profileRadioButtons = document.querySelectorAll('input[name="profile"]');
    const showAllPopupsToggle = document.getElementById('show-all-popups-toggle');
    const showDigipuntenToggle = document.getElementById('show-digipunten-toggle');
    const showExternalPartnersToggle = document.getElementById('show-external-partners-toggle');
    const showStationsToggle = document.getElementById('show-stations-toggle');

    const searchInputEl = document.getElementById('search-input');
    const searchResultsListEl = document.getElementById('search-results-list');
    const toggleMapClickModeButton = document.getElementById('toggle-map-click-mode');
    const toggleInstructionsBtn = document.getElementById('toggle-instructions-btn');

    const digipuntIcon = new L.Icon.Default(); // Standard blue marker for digipunten
    const stationEmojiIcon = L.divIcon({
        className: 'station-emoji-marker', html: '🚂',
        iconSize: [36, 36], iconAnchor: [18, 18], popupAnchor: [0, -18]
    });
    const externalPartnerEmojiIcon = L.divIcon({
        className: 'external-partner-emoji-marker', html: '📌',
        iconSize: [36, 36], iconAnchor: [18, 18], popupAnchor: [0, -18]
    });


    function toRad(x) { return x * Math.PI / 180; }
    function haversineDistance(coords1, coords2) {
        const R = 6371;
        const dLat = toRad(coords2.lat - coords1.lat);
        const dLon = toRad(coords2.lng - coords1.lng);
        const lat1 = toRad(coords1.lat);
        const lat2 = toRad(coords2.lat);
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
    }

    function isStation(loc) { return loc && trainStations.some(s => s.id === loc.id); }
    function isExternalPartner(loc) { return loc && externalPartners.some(p => p.id === loc.id); }
    function isDigipunt(loc) { return loc && locations.some(l => l.id === loc.id); }


    function getPopupContent(loc) {
        if (!loc) return "";
        if (currentMode === 'kaartweergave' || !loc.id || loc.id.startsWith('custom-')) { // Show details for custom locations in any mode if they are the focus, or for any in kaartweergave
            let imageHtml = '';
            if (loc.image) {
                imageHtml = `<img src="${loc.image}" alt="${loc.title}" class="popup-image">`;
            }

            let content = `<strong>${loc.title}</strong>`;
            if (loc.address) content += `<br><em>${loc.address}</em>`;
            content += imageHtml;

            let hoursContentHtml = '';
            if (loc.hours && loc.hours.length > 0) {
                hoursContentHtml += loc.hours.join('<br>');
            }
            if (loc.break && loc.break.start && loc.break.end) {
                 if (hoursContentHtml) {
                    hoursContentHtml += `<div style="height: 8px;"></div><hr style="border: none; border-top: 1px solid #eee; margin: 8px 0;">`;
                 }
                 hoursContentHtml += `Pauze: van ${loc.break.start} tot ${loc.break.end}`;
            }

            if (hoursContentHtml) {
                 content += `<div class="hours-block">${hoursContentHtml}</div>`;
            } else if (!loc.address && !imageHtml && !(loc.hours && loc.hours.length > 0) && !(loc.break && loc.break.start && loc.break.end)) {
                 // Only add this if absolutely no other detail is present
                 if (!loc.id || !loc.id.startsWith('custom-')) // Don't show for custom points unless truly empty
                    content += `<br><em style="font-size:0.9em; color:#777;">(Gedetailleerde info niet beschikbaar)</em>`;
            }
            return `<div class="kaartweergave-popup-content">${content}</div>`;
        }
        // Default content for other modes (will be overridden by specific mode functions if needed)
        return `<b>${loc.title}</b>`;
    }

    function getMarkerForLocation(locData) {
        if (!locData) return null;

        if (locData === haversineSelectedLocation && locData.id.startsWith('custom-')) return customHaversineMarker;
        if (locData === directionsStartLocation && locData.id.startsWith('custom-')) return customDirectionsStartPtMarker;
        if (locData === directionsEndLocation && locData.id.startsWith('custom-')) return customDirectionsEndPtMarker;
        if (locData === proximityCenterLocation && locData.id.startsWith('custom-')) return customProximityCenterPtMarker;
        if (locData === activeSearchedLocation && locData.id.startsWith('custom-')) return searchedLocationMarker; // Transient search

        return mapMarkers[locData.id] || null; // For predefined locations
    }


    function shouldMarkerBeVisible(loc) {
         if (!loc) return false;
         // Check if it's one of the "committed" custom points or the active transient search
         if ( (loc === haversineSelectedLocation && customHaversineMarker) ||
              (loc === directionsStartLocation && customDirectionsStartPtMarker) ||
              (loc === directionsEndLocation && customDirectionsEndPtMarker) ||
              (loc === proximityCenterLocation && customProximityCenterPtMarker) ||
              (loc === activeSearchedLocation && searchedLocationMarker) ) {
            return true;
         }

         if (currentMode === 'kaartweergave') {
             if (isDigipunt(loc)) return showDigipunten;
             if (isExternalPartner(loc)) return showExternalPartners;
             if (isStation(loc)) return showStations;
             return false;
         }
         // For other modes, visibility based on generic toggles
         if (isStation(loc)) return showStations;
         if (isExternalPartner(loc)) return showExternalPartners;
         if (isDigipunt(loc)) return showDigipunten;
         return false;
    }

    function updateMarkerVisibility() {
         // Predefined markers
         allLocations.forEach(loc => {
             const marker = mapMarkers[loc.id];
             if (!marker) return;
             if (shouldMarkerBeVisible(loc)) { if (!map.hasLayer(marker)) marker.addTo(map); }
             else { if (map.hasLayer(marker)) { map.removeLayer(marker); marker.closePopup(); }}
         });

         // Custom committed markers
         [customHaversineMarker, customDirectionsStartPtMarker, customDirectionsEndPtMarker, customProximityCenterPtMarker, searchedLocationMarker].forEach(customMarker => {
             if (customMarker) { // Assumes if marker exists, its corresponding data (e.g. haversineSelectedLocation) makes it visible
                 if (!map.hasLayer(customMarker)) customMarker.addTo(map);
             }
         });
         // If a custom marker was removed (e.g. customHaversineMarker = null), it won't be added.
         // The shouldMarkerBeVisible logic handles if the *data* is still active.
         // This needs to be more precise: only add custom markers if their *data* is active and they should be visible.
         // The `shouldMarkerBeVisible` function already checks this.
         // The above loop is redundant if `shouldMarkerBeVisible` is comprehensive.
         // The main point is: if a marker (predefined or custom) should be visible, add it. Else remove it.

        // Re-check custom markers based on their data objects
        const customPointsDataAndMarkers = [
            { data: haversineSelectedLocation, marker: customHaversineMarker },
            { data: directionsStartLocation, marker: customDirectionsStartPtMarker },
            { data: directionsEndLocation, marker: customDirectionsEndPtMarker },
            { data: proximityCenterLocation, marker: customProximityCenterPtMarker },
            { data: activeSearchedLocation, marker: searchedLocationMarker }
        ];

        customPointsDataAndMarkers.forEach(item => {
            if (item.marker && item.data) { // If both marker and its data exist
                if (shouldMarkerBeVisible(item.data)) {
                    if (!map.hasLayer(item.marker)) item.marker.addTo(map);
                } else {
                    if (map.hasLayer(item.marker)) { map.removeLayer(item.marker); item.marker.closePopup(); }
                }
            }
        });
    }


    function updatePopupVisibility() {
        const popupsToOpenMarkers = new Set();
        const allActiveCustomMarkers = [customHaversineMarker, customDirectionsStartPtMarker, customDirectionsEndPtMarker, customProximityCenterPtMarker, searchedLocationMarker].filter(Boolean);

        if (currentMode === 'kaartweergave') {
            if (showAllPopups) {
                allLocations.forEach(loc => {
                    const marker = mapMarkers[loc.id];
                    if (marker && map.hasLayer(marker) && shouldMarkerBeVisible(loc)) {
                         popupsToOpenMarkers.add(marker);
                    }
                });
                // Show popup for active searched location if it exists and is visible
                if (activeSearchedLocation && searchedLocationMarker && map.hasLayer(searchedLocationMarker) && shouldMarkerBeVisible(activeSearchedLocation)) {
                     popupsToOpenMarkers.add(searchedLocationMarker);
                }
            } else {
                 // If not showAllPopups, only the specifically clicked/searched item's popup might be open (handled by click handlers)
                 // Or if a custom search point is active, its popup is usually opened by processCustomLocationSelection
                 if (activeSearchedLocation && searchedLocationMarker && map.hasLayer(searchedLocationMarker) && shouldMarkerBeVisible(activeSearchedLocation)) {
                    // If it's open and should be, keep it. This function is more about mass open/close.
                    // Individual open actions are in click handlers.
                 }
            }
        } else { // Haversine, Directions, Proximity modes
            // Open popups for selected/active points in these modes
            [haversineSelectedLocation, directionsStartLocation, directionsEndLocation, proximityCenterLocation].filter(Boolean).forEach(selectedLoc => {
                const marker = getMarkerForLocation(selectedLoc); // Gets predefined or specific custom marker
                if (marker && map.hasLayer(marker) && shouldMarkerBeVisible(selectedLoc)) {
                    popupsToOpenMarkers.add(marker);
                }
            });

            if (showAllPopups) { // Also apply showAllPopups to other visible markers
                allLocations.forEach(loc => {
                    if (mapMarkers[loc.id] && map.hasLayer(mapMarkers[loc.id]) && shouldMarkerBeVisible(loc)) {
                        popupsToOpenMarkers.add(mapMarkers[loc.id]);
                    }
                });
                // And for any custom markers that are visible but not part of the primary selection (less common)
                allActiveCustomMarkers.forEach(customMarker => {
                    // Find data object for this marker to check shouldMarkerBeVisible
                    let dataForMarker = null;
                    if (customMarker === customHaversineMarker) dataForMarker = haversineSelectedLocation;
                    else if (customMarker === customDirectionsStartPtMarker) dataForMarker = directionsStartLocation;
                    else if (customMarker === customDirectionsEndPtMarker) dataForMarker = directionsEndLocation;
                    else if (customMarker === customProximityCenterPtMarker) dataForMarker = proximityCenterLocation;
                    else if (customMarker === searchedLocationMarker) dataForMarker = activeSearchedLocation;

                    if (dataForMarker && map.hasLayer(customMarker) && shouldMarkerBeVisible(dataForMarker)) {
                        popupsToOpenMarkers.add(customMarker);
                    }
                });
            }
        }

        // Close all popups first (that are not in the popupsToOpenMarkers set)
        allLocations.forEach(loc => { // Predefined
            const markerInstance = mapMarkers[loc.id];
            if (markerInstance && markerInstance.isPopupOpen() && !popupsToOpenMarkers.has(markerInstance)) {
                markerInstance.closePopup();
            }
        });
        allActiveCustomMarkers.forEach(customMarker => { // Custom
             if (customMarker.isPopupOpen() && !popupsToOpenMarkers.has(customMarker)) {
                 customMarker.closePopup();
             }
        });


        // Open determined popups
        popupsToOpenMarkers.forEach(markerInstance => {
            if (map.hasLayer(markerInstance) && !markerInstance.isPopupOpen()) {
                 markerInstance.openPopup();
            }
        });
    }


    function resetAllPopupContent() {
         allLocations.forEach(loc => { // Predefined markers
            if (mapMarkers[loc.id]) {
                 mapMarkers[loc.id].setPopupContent(getPopupContent(loc));
            }
        });
        // Custom markers - their popups are usually set when they are created or when their role changes.
        // This function is mostly for resetting predefined location popups to their default content for the current mode.
        [customHaversineMarker, customDirectionsStartPtMarker, customDirectionsEndPtMarker, customProximityCenterPtMarker, searchedLocationMarker].filter(Boolean).forEach(marker => {
            let locData = null;
            if (marker === customHaversineMarker) locData = haversineSelectedLocation;
            else if (marker === customDirectionsStartPtMarker) locData = directionsStartLocation;
            else if (marker === customDirectionsEndPtMarker) locData = directionsEndLocation;
            else if (marker === customProximityCenterPtMarker) locData = proximityCenterLocation;
            else if (marker === searchedLocationMarker) locData = activeSearchedLocation;
            if (locData) marker.setPopupContent(getPopupContent(locData)); // Update with potentially mode-specific default content
        });
    }

    function clearMapDrawings() {
        drawnHaversinePolylines.forEach(line => map.removeLayer(line));
        drawnHaversinePolylines = [];
        if (drawnDirectionsRoutePolyline) { map.removeLayer(drawnDirectionsRoutePolyline); drawnDirectionsRoutePolyline = null; }
        if (drawnProximityShape) { map.removeLayer(drawnProximityShape); drawnProximityShape = null; }
    }

    function clearProximityResultsAndShape() {
        proximityResults.length = 0;
        if (proximityResultsListEl) proximityResultsListEl.innerHTML = '';
        if (proximityStatusMessageEl) {
            proximityStatusMessageEl.style.display = 'none';
            proximityStatusMessageEl.textContent = '';
        }
        if (proximityInfoDiv) proximityInfoDiv.style.display = 'none';

        if (drawnProximityShape) {
            map.removeLayer(drawnProximityShape);
            drawnProximityShape = null;
        }
    }

    function clearSpecificCustomMarkersAndData() {
        if (customHaversineMarker) { map.removeLayer(customHaversineMarker); customHaversineMarker = null; }
        if (customDirectionsStartPtMarker) { map.removeLayer(customDirectionsStartPtMarker); customDirectionsStartPtMarker = null; }
        if (customDirectionsEndPtMarker) { map.removeLayer(customDirectionsEndPtMarker); customDirectionsEndPtMarker = null; }
        if (customProximityCenterPtMarker) { map.removeLayer(customProximityCenterPtMarker); customProximityCenterPtMarker = null; }

        // Corresponding data needs to be cleared if it points to a custom location that's being removed
        // This is handled by setting haversineSelectedLocation etc. to null in clearSelectionsAndUI
    }


    function clearSelectionsAndUI() {
        haversineSelectedLocation = null;
        directionsStartLocation = null;
        directionsEndLocation = null;
        proximityCenterLocation = null;

        clearSpecificCustomMarkersAndData(); // Clears committed custom markers

        if (searchedLocationMarker) { // Clears transient search marker
            map.removeLayer(searchedLocationMarker);
            searchedLocationMarker = null;
        }
        activeSearchedLocation = null; // Clears transient search data
        searchInputEl.value = '';
        searchResultsListEl.innerHTML = '';

        if (isMapClickModeActive) {
            isMapClickModeActive = false;
            toggleMapClickModeButton.classList.remove('active');
            toggleMapClickModeButton.textContent = 'Pinpunt Locatie op Kaart';
            map.getContainer().style.cursor = '';
        }

        document.querySelectorAll('li[data-id]').forEach(item => {
            item.classList.remove('selected-haversine', 'selected-directions-start', 'selected-directions-end', 'selected-proximity-center');
        });

        clearMapDrawings();
        resetAllPopupContent();

        haversineInfoDiv.style.display = 'none'; haversineDistanceListEl.innerHTML = ''; selectedLocationNameHaversineEl.textContent = 'nvt';
        directionsInfoDiv.style.display = 'none'; directionsRouteSummaryEl.innerHTML = ''; currentProfileDisplayEl.textContent = getProfileDisplayName(selectedRouteProfile);

        clearProximityResultsAndShape();
        proximityCenterNameEl.textContent = 'nvt';
        proximityParametersDisplayEl.innerHTML = '';

        updateMarkerVisibility();
        updatePopupVisibility();
        updateInstructions();
    }


    function getProfileDisplayName(profileValue) {
        switch(profileValue) {
            case 'driving-car': return 'Auto';
            case 'cycling-regular': return 'Fiets';
            case 'foot-walking': return 'Voetganger';
            default: return profileValue;
        }
    }

    function updateInstructions() {
        let startName = directionsStartLocation ? directionsStartLocation.title : '';
        let endName = directionsEndLocation ? directionsEndLocation.title : '';
        let haversineName = haversineSelectedLocation ? haversineSelectedLocation.title : '';
        let proximityCenterName = proximityCenterLocation ? proximityCenterLocation.title : '';


        if (currentMode === 'kaartweergave') {
            instructionsEl.innerHTML = `<p>Dit is de kaartweergave. Klik op een marker om details te zien: blauwe markers (Digipunten), 📌 (Externe Partners), of 🚂 (Treinstations).</p>
                                        <p>Gebruik de 'Weergave Opties' selectievakjes om deze categorieën op de kaart te tonen of te verbergen.</p>
                                        <p>Vink "Toon alle locatie data op kaart" aan om de details van alle zichtbare locaties tegelijk in popups te tonen.</p>
                                        <p>Klikken op een item in de lijsten hieronder zal ook de betreffende categorie (en de bijbehorende checkbox) activeren en zichtbaar maken op de kaart.</p>`;
        } else if (currentMode === 'haversine') {
            let instructionText = `<p>Selecteer een locatie uit de lijst, zoek een locatie, of gebruik 'Pinpunt Locatie op Kaart' om afstanden in vogelvlucht te zien.</p>`;
            if (haversineSelectedLocation) {
                instructionText = `<p>Afstanden berekend vanaf: <strong style="color: #007aff;">${haversineName}</strong>.</p>` + instructionText;
            }
            instructionsEl.innerHTML = instructionText;
        } else if (currentMode === 'directions') {
            let instructionText = "<p>1. Selecteer een STARTPUNT (via lijst, zoek, of 'Pinpunt Locatie op Kaart').</p>";
            if (directionsStartLocation && !directionsEndLocation) {
                instructionText = `<p>Geselecteerd Startpunt: <span id="selected-location-name-directions-start">${startName}</span></p>`;
                instructionText += `<p>2. Selecteer een andere locatie (uit de lijst of kaart) als EINDPUNT voor ${getProfileDisplayName(selectedRouteProfile)} route.</p>`;
            } else if (directionsStartLocation && directionsEndLocation) {
                 instructionText = `<p>Route van <span id="selected-location-name-directions-start">${startName}</span> naar <span id="selected-location-name-directions-end">${endName}</span> getoond.</p>`;
                 instructionText += "<p>Klik op 'Selectie Herstellen' of een nieuwe locatie/zoekopdracht om een nieuwe route te starten.</p>";
            }
            instructionsEl.innerHTML = instructionText;
        } else if (currentMode === 'proximity') {
            let instructionText = "<p>1. Selecteer een CENTRUMPUNT voor de analyse (via lijst, zoek, of 'Pinpunt Locatie op Kaart').</p>";
            if (proximityCenterLocation) {
                instructionText = `<p>Centrumpunt: <strong style="color: #ff9500;">${proximityCenterName}</strong>.</p>`;
                instructionText += "<p>2. Configureer het type analyse (afstand/reistijd), stel de parameters in en klik op 'Vind Nabije Locaties'.</p>";
            }
            instructionsEl.innerHTML = instructionText;
        }
    }

    function displayHaversineDistances(selectedLoc) {
        if (!selectedLoc) return;
        clearMapDrawings();
        // resetAllPopupContent(); // Called by some paths, ensure it's consistent

        selectedLocationNameHaversineEl.textContent = selectedLoc.title;
        haversineDistanceListEl.innerHTML = '';
        haversineInfoDiv.style.display = 'block';
        directionsInfoDiv.style.display = 'none';
        proximityInfoDiv.style.display = 'none';

        const markerToFocus = getMarkerForLocation(selectedLoc);

        if (markerToFocus && map.hasLayer(markerToFocus)) {
             map.setView(selectedLoc.location, map.getZoom() < 13 ? 13 : map.getZoom());
             markerToFocus.setPopupContent(`<b>${selectedLoc.title}</b><br>(STARTPUNT AFSTANDEN)`).openPopup();
        } else if (selectedLoc.location) { // Fallback if marker somehow not ready
             map.setView(selectedLoc.location, map.getZoom() < 13 ? 13 : map.getZoom());
        }


        const distancesData = [];
        allLocations.forEach(otherLoc => { // Compare with predefined locations
             if (selectedLoc.id === otherLoc.id || !mapMarkers[otherLoc.id]) return;
             if (shouldMarkerBeVisible(otherLoc)) {
                 const otherMarker = mapMarkers[otherLoc.id]; // Always from mapMarkers for "other"
                 const distance = haversineDistance(selectedLoc.location, otherLoc.location);
                 otherMarker.setPopupContent(`<b>${otherLoc.title}</b><br>Afstand: ${distance.toFixed(2)} km`);
                 distancesData.push({ id: otherLoc.id, title: otherLoc.title, distance: distance });
                 if (markerToFocus && map.hasLayer(markerToFocus) && map.hasLayer(otherMarker)) {
                      const line = L.polyline([selectedLoc.location, otherLoc.location], { color: '#ff0000', weight: 2, opacity: 0.75 }).addTo(map);
                      drawnHaversinePolylines.push(line);
                 }
             }
        });

        distancesData.sort((a, b) => a.distance - b.distance);
        distancesData.forEach(data => {
            const listItem = document.createElement('li');
            listItem.textContent = `${data.title}: ${data.distance.toFixed(2)} km`;
            haversineDistanceListEl.appendChild(listItem);
        });
        if (distancesData.length === 0) {
            haversineDistanceListEl.innerHTML = '<li>Geen andere zichtbare locaties om afstanden mee te berekenen.</li>';
        }
        updatePopupVisibility(); // Ensure correct popups are open/closed
    }


    async function fetchAndDrawORSRoute(startLoc, endLoc) {
        if (!startLoc || !endLoc) return;
        clearMapDrawings();
        // resetAllPopupContent(); // Called by some paths

        directionsRouteSummaryEl.innerHTML = `<p class="loading-message">Route berekenen voor ${getProfileDisplayName(selectedRouteProfile)}...</p>`;
        directionsInfoDiv.style.display = 'block';
        haversineInfoDiv.style.display = 'none';
        proximityInfoDiv.style.display = 'none';

        if (!ORS_API_KEY || ORS_API_KEY.startsWith("5b3ce3597851110001cf6248") && ORS_API_KEY.length < 40) {
             directionsRouteSummaryEl.innerHTML = `<p class="error-message">OpenRouteService API Sleutel is niet (correct) ingesteld. Kan geen routes berekenen.</p>`;
             updatePopupVisibility(); return;
         }

        const requestBody = { coordinates: [[startLoc.location.lng, startLoc.location.lat], [endLoc.location.lng, endLoc.location.lat]] };
        try {
            const apiUrl = `https://api.openrouteservice.org/v2/directions/${selectedRouteProfile}/geojson`;
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Authorization': ORS_API_KEY, 'Accept': 'application/json, application/geo+json', 'Content-Type': 'application/json; charset=utf-8' },
                body: JSON.stringify(requestBody)
            });
            if (!response.ok) {
                let errorDetails = 'Onbekende fout';
                try { const errorData = await response.json(); errorDetails = errorData.error?.message || JSON.stringify(errorData); }
                catch (e) { errorDetails = await response.text(); }
                throw new Error(`ORS API Fout (${response.status}): ${errorDetails}`);
            }
            const data = await response.json();
            if (data.features && data.features.length > 0) {
                const route = data.features[0];
                drawnDirectionsRoutePolyline = L.geoJSON(route.geometry, { style: () => ({ color: "#e63946", weight: 5, opacity: 0.8 }) }).addTo(map);
                const distMeters = route.properties?.summary?.distance || 0;
                const durSeconds = route.properties?.summary?.duration || 0;
                const distKm = (distMeters / 1000).toFixed(2);
                const durMin = (durSeconds / 60).toFixed(1);
                directionsRouteSummaryEl.innerHTML = `
                    <p><strong>Van:</strong> ${startLoc.title}</p>
                    <p><strong>Naar:</strong> ${endLoc.title}</p>
                    <p><strong>Profiel:</strong> ${getProfileDisplayName(selectedRouteProfile)}</p>
                    <p><strong>Afstand:</strong> ${distKm} km</p>
                    <p><strong>Geschatte Duur:</strong> ${durMin} min</p>`;

                const startMarkerInstance = getMarkerForLocation(startLoc);
                const endMarkerInstance = getMarkerForLocation(endLoc);

                 if (startMarkerInstance && map.hasLayer(startMarkerInstance)) startMarkerInstance.setPopupContent(`<b>${startLoc.title} (Start)</b><br>Route: ${distKm} km, ${durMin} min`).openPopup();
                 if (endMarkerInstance && map.hasLayer(endMarkerInstance)) endMarkerInstance.setPopupContent(`<b>${endLoc.title} (Eind)</b><br>Route: ${distKm} km, ${durMin} min`).openPopup();

                if (drawnDirectionsRoutePolyline.getBounds().isValid()) map.fitBounds(drawnDirectionsRoutePolyline.getBounds().pad(0.1));
            } else {
                directionsRouteSummaryEl.innerHTML = `<p class="error-message">Geen route gevonden voor ${getProfileDisplayName(selectedRouteProfile)}.</p>`;
            }
        } catch (error) {
             directionsRouteSummaryEl.innerHTML = `<p class="error-message">Route berekening mislukt.<br>${error.message}</p>`;
        }
        updatePopupVisibility(); // After setting specific popups, this ensures others are handled (e.g. showAllPopups logic)
        updateInstructions();
    }

    async function performProximityAnalysis() {
        if (!proximityCenterLocation) {
            proximityStatusMessageEl.textContent = 'Selecteer eerst een centrumpunt voor de analyse.';
            proximityStatusMessageEl.className = 'error-message';
            proximityStatusMessageEl.style.display = 'block';
            proximityInfoDiv.style.display = 'block'; // Show panel to display message
            proximityResultsListEl.innerHTML = '';
            return;
        }

        clearProximityResultsAndShape();
        // resetAllPopupContent(); // Called by some paths

        proximityInfoDiv.style.display = 'block';
        proximityCenterNameEl.textContent = proximityCenterLocation.title;
        proximityResultsListEl.innerHTML = '';
        proximityStatusMessageEl.textContent = 'Analyse uitvoeren...';
        proximityStatusMessageEl.className = 'loading-message';
        proximityStatusMessageEl.style.display = 'block';

        const centerMarkerInstance = getMarkerForLocation(proximityCenterLocation);
        if (centerMarkerInstance && map.hasLayer(centerMarkerInstance)) {
            centerMarkerInstance.setPopupContent(`<b>${proximityCenterLocation.title}</b><br>(CENTRUMPUNT NABIJHEID)`).openPopup();
        }

        proximityRadiusKm = parseFloat(proximityRadiusInput.value);
        proximityTimeMinutes = parseInt(proximityTimeInput.value);
        proximityTravelProfile = proximityProfileSelect.value;

        if (proximityAnalysisType === 'distance') {
            await findNearbyByDistance();
        } else if (proximityAnalysisType === 'time') {
            await findNearbyByTime();
        }
        displayProximityResults();
    }

    async function findNearbyByDistance() {
        const center = proximityCenterLocation.location;
        const radiusMeters = proximityRadiusKm * 1000;

        drawnProximityShape = L.circle(center, {
            radius: radiusMeters,
            color: '#ff9500', fillColor: '#ff9500', fillOpacity: 0.15, weight: 2
        }).addTo(map);
        if (map.hasLayer(drawnProximityShape)) map.fitBounds(drawnProximityShape.getBounds().pad(0.05));

        allLocations.forEach(loc => {
            if (loc.id === proximityCenterLocation.id || !shouldMarkerBeVisible(loc)) return; // Check visibility
            const distKm = haversineDistance(center, loc.location);
            if (distKm <= proximityRadiusKm) {
                proximityResults.push({ ...loc, distance: distKm.toFixed(2) });
            }
        });
        proximityResults.sort((a,b) => parseFloat(a.distance) - parseFloat(b.distance));
    }

    async function findNearbyByTime() {
        if (!ORS_API_KEY || ORS_API_KEY.startsWith("5b3ce3597851110001cf6248") && ORS_API_KEY.length < 40) {
            proximityStatusMessageEl.textContent = 'OpenRouteService API Sleutel niet (correct) ingesteld. Kan geen reistijdanalyse uitvoeren.';
            proximityStatusMessageEl.className = 'error-message';
            proximityStatusMessageEl.style.display = 'block';
            return;
        }

        const centerCoords = [proximityCenterLocation.location.lng, proximityCenterLocation.location.lat];
        const timeSeconds = proximityTimeMinutes * 60;

        const requestBody = {
            locations: [centerCoords],
            range: [timeSeconds],
            range_type: "time",
            attributes: ["area", "reachfactor"]
        };
        const apiUrl = `https://api.openrouteservice.org/v2/isochrones/${proximityTravelProfile}`;

        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Authorization': ORS_API_KEY, 'Content-Type': 'application/json; charset=utf-8' },
                body: JSON.stringify(requestBody)
            });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`ORS Isochrone API Fout (${response.status}): ${errorData.error?.message || JSON.stringify(errorData)}`);
            }
            const data = await response.json();
            if (data.features && data.features.length > 0) {
                const isochroneGeoJSON = data.features[0];
                drawnProximityShape = L.geoJSON(isochroneGeoJSON, {
                    style: () => ({ color: "#2a9d8f", weight: 2, fillColor: "#2a9d8f", fillOpacity: 0.25 })
                }).addTo(map);
                if (map.hasLayer(drawnProximityShape)) map.fitBounds(drawnProximityShape.getBounds().pad(0.05));

                allLocations.forEach(loc => {
                    if (loc.id === proximityCenterLocation.id || !shouldMarkerBeVisible(loc)) return; // Check visibility

                    const turfPoint = turf.point([loc.location.lng, loc.location.lat]);
                    let isInside = false;
                    // Check against each polygon in the FeatureCollection (isochrones can be multi-polygon)
                    if (drawnProximityShape.feature && drawnProximityShape.feature.geometry.type === 'Polygon') {
                        if (turf.booleanPointInPolygon(turfPoint, drawnProximityShape.feature)) isInside = true;
                    } else if (drawnProximityShape.feature && drawnProximityShape.feature.geometry.type === 'MultiPolygon') {
                         drawnProximityShape.feature.geometry.coordinates.forEach(polygonCoords => {
                            if (turf.booleanPointInPolygon(turfPoint, turf.polygon(polygonCoords))) isInside = true;
                        });
                    } else { // Fallback for GeoJSON layer group from L.geoJSON
                        drawnProximityShape.eachLayer(featureLayer => {
                            if (featureLayer.feature && featureLayer.feature.geometry) {
                                if (turf.booleanPointInPolygon(turfPoint, featureLayer.feature)) {
                                    isInside = true;
                                }
                            }
                        });
                    }

                    if (isInside) {
                        proximityResults.push({ ...loc });
                    }
                });
                proximityResults.sort((a,b) => a.title.localeCompare(b.title));
            } else {
                proximityStatusMessageEl.textContent = 'Geen bereikbaar gebied gevonden voor de opgegeven tijd en profiel.';
                proximityStatusMessageEl.className = 'error-message';
            }
        } catch (error) {
            proximityStatusMessageEl.textContent = `Fout bij reistijdanalyse: ${error.message}`;
            proximityStatusMessageEl.className = 'error-message';
        }
    }

    function displayProximityResults() {
        proximityResultsListEl.innerHTML = '';
        proximityStatusMessageEl.style.display = 'none';

        if (proximityAnalysisType === 'distance') {
            proximityParametersDisplayEl.innerHTML = `Type: Afstand, Radius: ${proximityRadiusKm} km`;
        } else {
            proximityParametersDisplayEl.innerHTML = `Type: Reistijd, Duur: ${proximityTimeMinutes} min, Profiel: ${getProfileDisplayName(proximityTravelProfile)}`;
        }

        if (proximityResults.length === 0) {
            const li = document.createElement('li');
            li.textContent = 'Geen locaties gevonden binnen het opgegeven gebied/de tijd.';
            proximityResultsListEl.appendChild(li);
        } else {
            proximityResults.forEach(loc => {
                const li = document.createElement('li');
                let text = loc.title;
                if (loc.distance) text += ` (${loc.distance} km)`; // distance only available for distance analysis
                li.textContent = text;

                // Update popups of result markers if they are predefined locations
                const resultMarker = mapMarkers[loc.id];
                if(resultMarker && map.hasLayer(resultMarker)) {
                    let popupText = `<b>${loc.title}</b><br>Nabij ${proximityCenterLocation.title}`;
                    if (loc.distance) popupText += ` (${loc.distance} km)`;
                    resultMarker.setPopupContent(popupText);
                }
                proximityResultsListEl.appendChild(li);
            });
        }
        proximityInfoDiv.style.display = 'block';
        updatePopupVisibility(); // Ensure correct popups are open/closed
    }

    function debounce(func, delay) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), delay);
        };
    }

    async function fetchPeliasSuggestions(query) {
        if (query.length < 3) { searchResultsListEl.innerHTML = ''; return; }
        if (!ORS_API_KEY || ORS_API_KEY.startsWith("5b3ce3597851110001cf6248") && ORS_API_KEY.length < 40) {
            searchResultsListEl.innerHTML = '<li>API sleutel niet geconfigureerd. Zoeken niet beschikbaar.</li>'; return;
        }
        const peliasUrl = `https://api.openrouteservice.org/geocode/autocomplete?api_key=${ORS_API_KEY}&text=${encodeURIComponent(query)}&focus.point.lon=${GHENT_FOCUS_POINT.lng}&focus.point.lat=${GHENT_FOCUS_POINT.lat}&boundary.country=BE`;
        try {
            const response = await fetch(peliasUrl);
            if (!response.ok) {
                let errorDetails = 'Onbekende fout';
                try { const errorData = await response.json(); errorDetails = errorData.error?.message || JSON.stringify(errorData); }
                catch (e) { errorDetails = await response.text(); }
                searchResultsListEl.innerHTML = `<li>Fout bij zoeken: ${errorDetails.substring(0, 100)}...</li>`; return;
            }
            const data = await response.json();
            displayPeliasSuggestions(data.features);
        } catch (error) {
            searchResultsListEl.innerHTML = '<li>Zoekopdracht mislukt.</li>';
        }
    }

    function displayPeliasSuggestions(features) {
        searchResultsListEl.innerHTML = '';
        if (!features || features.length === 0) { searchResultsListEl.innerHTML = '<li>Geen resultaten gevonden.</li>'; return; }
        features.forEach(feature => {
            const li = document.createElement('li');
            li.textContent = feature.properties.label;
            // Capture feature data for the closure
            const label = feature.properties.label;
            const coords = feature.geometry.coordinates; // [lng, lat]
            li.addEventListener('click', () => {
                 handlePeliasResultClick(label, coords);
            });
            searchResultsListEl.appendChild(li);
        });
    }
    const debouncedFetchSuggestions = debounce(fetchPeliasSuggestions, 300);


   function processCustomLocationSelection(label, coordinates_lng_lat, source = "search") {
        searchInputEl.value = label; // Display selected label in search bar
        searchResultsListEl.innerHTML = ''; // Clear suggestions

        // Remove previous transient searchedLocationMarker, if any. Committed markers are handled by mode logic.
        if (searchedLocationMarker) {
            map.removeLayer(searchedLocationMarker);
            searchedLocationMarker = null;
        }
        activeSearchedLocation = null; // Clear previous transient search data

        // Create new data and marker for the current search/click
        activeSearchedLocation = {
            id: `custom-${source}-${Date.now()}`, title: label,
            location: { lat: coordinates_lng_lat[1], lng: coordinates_lng_lat[0] }
        };
        searchedLocationMarker = L.marker(activeSearchedLocation.location, { icon: digipuntIcon })
            .addTo(map)
            .bindPopup(getPopupContent(activeSearchedLocation))
            .openPopup();
        map.setView(activeSearchedLocation.location, Math.max(map.getZoom(), 15));

        // Clear selection styling from PREDEFINED list items
        document.querySelectorAll('li[data-id]').forEach(item => item.classList.remove('selected-haversine', 'selected-directions-start', 'selected-directions-end', 'selected-proximity-center'));

        // --- Mode-specific logic for the newly searched/clicked location ---
        if (currentMode === 'kaartweergave') {
            // In kaartweergave, a new search just displays the point.
            // Clear any other mode's specific custom points and data.
            if (customHaversineMarker) { map.removeLayer(customHaversineMarker); customHaversineMarker = null; }
            if (customDirectionsStartPtMarker) { map.removeLayer(customDirectionsStartPtMarker); customDirectionsStartPtMarker = null; }
            if (customDirectionsEndPtMarker) { map.removeLayer(customDirectionsEndPtMarker); customDirectionsEndPtMarker = null; }
            if (customProximityCenterPtMarker) { map.removeLayer(customProximityCenterPtMarker); customProximityCenterPtMarker = null; }
            haversineSelectedLocation = null;
            directionsStartLocation = null; directionsEndLocation = null;
            proximityCenterLocation = null;
            // The new searchedLocationMarker is already on map and its popup open.
        } else if (currentMode === 'haversine') {
            if (customHaversineMarker) { map.removeLayer(customHaversineMarker); customHaversineMarker = null; } // Clear old custom haversine point
            haversineSelectedLocation = activeSearchedLocation; // New search becomes the center
            customHaversineMarker = searchedLocationMarker;     // Commit its marker
            searchedLocationMarker = null;                      // Mark as committed (no longer transient)

            // Clear other modes' selections
            directionsStartLocation = null; directionsEndLocation = null; proximityCenterLocation = null;
            if (customDirectionsStartPtMarker) { map.removeLayer(customDirectionsStartPtMarker); customDirectionsStartPtMarker = null; }
            if (customDirectionsEndPtMarker) { map.removeLayer(customDirectionsEndPtMarker); customDirectionsEndPtMarker = null; }
            if (customProximityCenterPtMarker) { map.removeLayer(customProximityCenterPtMarker); customProximityCenterPtMarker = null; }

            displayHaversineDistances(haversineSelectedLocation);
        } else if (currentMode === 'directions') {
            proximityCenterLocation = null; // Clear proximity selections
            if (customProximityCenterPtMarker) { map.removeLayer(customProximityCenterPtMarker); customProximityCenterPtMarker = null; }


            if (!directionsStartLocation || (directionsStartLocation && directionsEndLocation)) { // Selecting a new START point
                // Clear previous start/end points and their custom markers
                if (customDirectionsStartPtMarker) { map.removeLayer(customDirectionsStartPtMarker); customDirectionsStartPtMarker = null; }
                if (customDirectionsEndPtMarker) { map.removeLayer(customDirectionsEndPtMarker); customDirectionsEndPtMarker = null; }

                directionsStartLocation = activeSearchedLocation; // New search is the start
                customDirectionsStartPtMarker = searchedLocationMarker; // Commit its marker
                searchedLocationMarker = null; // Mark as committed

                directionsEndLocation = null; // Reset end point

                clearMapDrawings(); // Clear previous route lines
                directionsInfoDiv.style.display = 'block';
                directionsRouteSummaryEl.innerHTML = `Startpunt: <b>${directionsStartLocation.title}</b>.<br>Selecteer Eindpunt.`;
                resetAllPopupContent(); // Reset other popups to default
                if(customDirectionsStartPtMarker) customDirectionsStartPtMarker.setPopupContent(`<b>${directionsStartLocation.title} (Start)</b>`).openPopup();

            } else { // Selecting an END point (directionsStartLocation is already set)
                if (customDirectionsEndPtMarker) { map.removeLayer(customDirectionsEndPtMarker); customDirectionsEndPtMarker = null; } // Clear previous custom end marker

                directionsEndLocation = activeSearchedLocation; // New search is the end
                customDirectionsEndPtMarker = searchedLocationMarker; // Commit its marker
                searchedLocationMarker = null; // Mark as committed

                // Ensure start point's popup is correct (especially if it was custom)
                const startMarkerToUpdate = getMarkerForLocation(directionsStartLocation);
                if (startMarkerToUpdate && map.hasLayer(startMarkerToUpdate)) {
                    startMarkerToUpdate.setPopupContent(`<b>${directionsStartLocation.title} (Start)</b>`).openPopup();
                }
                if (customDirectionsEndPtMarker && map.hasLayer(customDirectionsEndPtMarker)) { // Ensure end point's popup is also open
                     customDirectionsEndPtMarker.setPopupContent(`<b>${directionsEndLocation.title} (Eind)</b>`).openPopup();
                }


                fetchAndDrawORSRoute(directionsStartLocation, directionsEndLocation);
            }
        } else if (currentMode === 'proximity') {
            if (customProximityCenterPtMarker) { map.removeLayer(customProximityCenterPtMarker); customProximityCenterPtMarker = null; } // Clear old custom proximity point
            proximityCenterLocation = activeSearchedLocation; // New search becomes the center
            customProximityCenterPtMarker = searchedLocationMarker; // Commit its marker
            searchedLocationMarker = null; // Mark as committed

            // Clear other modes' selections
            haversineSelectedLocation = null; directionsStartLocation = null; directionsEndLocation = null;
            if (customHaversineMarker) { map.removeLayer(customHaversineMarker); customHaversineMarker = null; }
            if (customDirectionsStartPtMarker) { map.removeLayer(customDirectionsStartPtMarker); customDirectionsStartPtMarker = null; }
            if (customDirectionsEndPtMarker) { map.removeLayer(customDirectionsEndPtMarker); customDirectionsEndPtMarker = null; }


            clearProximityResultsAndShape();
            proximityCenterNameEl.textContent = proximityCenterLocation.title;
            proximityInfoDiv.style.display = 'none'; // Hide old results
            resetAllPopupContent(); // Reset other popups
            if(customProximityCenterPtMarker) customProximityCenterPtMarker.setPopupContent(`<b>${proximityCenterLocation.title}</b><br>(CENTRUMPUNT NABIJHEID)`).openPopup();
        }

        updateMarkerVisibility(); // Ensure all markers (predefined, committed custom, transient) are correctly shown/hidden
        updatePopupVisibility(); // Ensure popups are correctly managed
        updateInstructions();
    }


    function handlePeliasResultClick(label, coordinates_lng_lat) {
        processCustomLocationSelection(label, coordinates_lng_lat, "search");
    }

    function toggleMapClickSelectionMode() {
        isMapClickModeActive = !isMapClickModeActive;
        if (isMapClickModeActive) {
            toggleMapClickModeButton.classList.add('active');
            toggleMapClickModeButton.textContent = 'Annuleer Kaartselectie';
            map.getContainer().style.cursor = 'crosshair';
             searchInputEl.value = ''; // Clear search input when entering map click mode
             searchResultsListEl.innerHTML = ''; // Clear search results
        } else {
            toggleMapClickModeButton.classList.remove('active');
            toggleMapClickModeButton.textContent = 'Pinpunt Locatie op Kaart';
            map.getContainer().style.cursor = '';
        }
    }

    function handleModeChange(event) {
        const oldMode = currentMode;
        currentMode = event.target.value;

        // Preserve active transient search if user switches mode with an uncommitted search
        const preservedActiveSearchData = activeSearchedLocation;
        const preservedActiveSearchMarker = searchedLocationMarker; // Marker itself

        clearSelectionsAndUI(); // This clears all selections, including activeSearchedLocation and its marker

        // Restore transient search if it existed, UNLESS the new mode is directions and it would become start/end immediately
        if (preservedActiveSearchData && preservedActiveSearchMarker) {
            activeSearchedLocation = preservedActiveSearchData;
            searchedLocationMarker = preservedActiveSearchMarker;
            if (!map.hasLayer(searchedLocationMarker)) { // Add it back if cleared
                searchedLocationMarker.addTo(map).openPopup();
            }
            // If switching to a mode that immediately uses the search point, process it
            if (currentMode === 'haversine') {
                 processCustomLocationSelection(activeSearchedLocation.title, [activeSearchedLocation.location.lng, activeSearchedLocation.location.lat], activeSearchedLocation.id.includes("mapclick") ? "mapclick" : "search");
            } else if (currentMode === 'proximity') {
                 processCustomLocationSelection(activeSearchedLocation.title, [activeSearchedLocation.location.lng, activeSearchedLocation.location.lat], activeSearchedLocation.id.includes("mapclick") ? "mapclick" : "search");
            } else if (currentMode === 'directions' && (!directionsStartLocation || (directionsStartLocation && directionsEndLocation))) {
                // If directions mode is ready for a start point, use the searched location
                processCustomLocationSelection(activeSearchedLocation.title, [activeSearchedLocation.location.lng, activeSearchedLocation.location.lat], activeSearchedLocation.id.includes("mapclick") ? "mapclick" : "search");
            }
             // For 'kaartweergave', the restored searchedLocationMarker is simply displayed.
        }


        appTitleEl.textContent = 'Loading...'; // Will be updated by updateInstructions or specific logic
        profileSelectorDiv.style.display = 'none';
        proximityControlsSection.style.display = 'none';
        // Info panels are hidden by clearSelectionsAndUI

        if (currentMode === 'kaartweergave') {
            appTitleEl.textContent = 'Haversine'; // Title seems to be fixed, adjust if needed
        } else if (currentMode === 'haversine') {
            appTitleEl.textContent = 'Haversine';
            if (haversineSelectedLocation) displayHaversineDistances(haversineSelectedLocation);
        } else if (currentMode === 'directions') {
            appTitleEl.textContent = 'Haversine';
            profileSelectorDiv.style.display = 'block';
            if (directionsStartLocation && directionsEndLocation) {
                fetchAndDrawORSRoute(directionsStartLocation, directionsEndLocation);
            } else if (directionsStartLocation) {
                directionsInfoDiv.style.display = 'block';
                directionsRouteSummaryEl.innerHTML = `Startpunt: <b>${directionsStartLocation.title}</b>.<br>Selecteer Eindpunt...`;
                const startMarker = getMarkerForLocation(directionsStartLocation);
                if(startMarker) startMarker.setPopupContent(`<b>${directionsStartLocation.title} (Start)</b>`).openPopup();
            }
        } else if (currentMode === 'proximity') {
            appTitleEl.textContent = 'Haversine';
            proximityControlsSection.style.display = 'block';
            if (proximityCenterLocation) {
                proximityCenterNameEl.textContent = proximityCenterLocation.title;
                const centerMarker = getMarkerForLocation(proximityCenterLocation);
                if(centerMarker) centerMarker.setPopupContent(`<b>${proximityCenterLocation.title}</b><br>(CENTRUMPUNT NABIJHEID)`).openPopup();
                // proximityInfoDiv might show old results if analysis was run, clear or re-run
            }
        }
        // Final updates after mode switch
        resetAllPopupContent();
        updateMarkerVisibility();
        updatePopupVisibility();
        updateInstructions();
    }


    function handleProfileChange(event) {
        selectedRouteProfile = event.target.value;
        currentProfileDisplayEl.textContent = getProfileDisplayName(selectedRouteProfile);
        updateInstructions();

        if (directionsStartLocation && directionsEndLocation) {
            fetchAndDrawORSRoute(directionsStartLocation, directionsEndLocation);
        } else if (directionsStartLocation) { // Only start selected, update prompt
            directionsInfoDiv.style.display = 'block';
            directionsRouteSummaryEl.innerHTML = `Startpunt: <b>${directionsStartLocation.title}</b>.<br>Selecteer Eindpunt voor ${getProfileDisplayName(selectedRouteProfile)} route...`;
        }
    }


    function handleLocationFilterChange() {
         updateMarkerVisibility(); // This will add/remove markers based on new filter state
         resetAllPopupContent();   // Reset popups to default content for the mode

        // If a selected location (predefined or custom) becomes hidden, clear the selection for that mode
        if (currentMode === 'haversine' && haversineSelectedLocation && !shouldMarkerBeVisible(haversineSelectedLocation)) {
            haversineSelectedLocation = null;
            if (customHaversineMarker) { map.removeLayer(customHaversineMarker); customHaversineMarker = null; }
            haversineInfoDiv.style.display = 'none';
            clearMapDrawings(); // Clear haversine lines
        } else if (currentMode === 'haversine' && haversineSelectedLocation) {
            displayHaversineDistances(haversineSelectedLocation); // Re-calculate with visible markers
        }

        if (currentMode === 'directions') {
            let clearDir = false;
            if (directionsStartLocation && !shouldMarkerBeVisible(directionsStartLocation)) clearDir = true;
            if (directionsEndLocation && !shouldMarkerBeVisible(directionsEndLocation)) clearDir = true;

            if (clearDir) {
                directionsStartLocation = null; directionsEndLocation = null;
                if (customDirectionsStartPtMarker) { map.removeLayer(customDirectionsStartPtMarker); customDirectionsStartPtMarker = null; }
                if (customDirectionsEndPtMarker) { map.removeLayer(customDirectionsEndPtMarker); customDirectionsEndPtMarker = null; }
                directionsInfoDiv.style.display = 'none';
                clearMapDrawings(); // Clear route lines
            } else if (directionsStartLocation && directionsEndLocation) {
                fetchAndDrawORSRoute(directionsStartLocation, directionsEndLocation); // Re-calculate route
            } else if (directionsStartLocation) { // Only start is set, update UI
                directionsInfoDiv.style.display = 'block';
                directionsRouteSummaryEl.innerHTML = `Startpunt: <b>${directionsStartLocation.title}</b>.<br>Selecteer Eindpunt...`;
            }
        }

        if (currentMode === 'proximity' && proximityCenterLocation && !shouldMarkerBeVisible(proximityCenterLocation)) {
            proximityCenterLocation = null;
            if (customProximityCenterPtMarker) { map.removeLayer(customProximityCenterPtMarker); customProximityCenterPtMarker = null; }
            clearProximityResultsAndShape(); // Clear analysis results and shape
            proximityInfoDiv.style.display = 'none';
        } else if (currentMode === 'proximity' && proximityCenterLocation && drawnProximityShape) {
            // If proximity analysis was run, results might change due to marker visibility.
            // Prompt user to re-run or automatically re-run. For now, clear and prompt.
            clearProximityResultsAndShape();
            proximityInfoDiv.style.display = 'block'; // Keep panel visible for message
            proximityStatusMessageEl.textContent = 'Zichtbaarheid van locaties is gewijzigd. Voer de analyse opnieuw uit.';
            proximityStatusMessageEl.className = 'loading-message'; // Or 'info-message'
            proximityStatusMessageEl.style.display = 'block';
        }
        updatePopupVisibility(); // Apply popup changes
        updateInstructions();
    }

    function handleLocationClick(clickedLocData, clickedListItemEl) {
    if (isMapClickModeActive) toggleMapClickSelectionMode(); // Exit map click mode if active

    // If a list item is clicked, any transient search result is cleared.
    if (clickedListItemEl) { // Only if a list item was clicked, not a map marker for a custom point
        if (searchedLocationMarker) { map.removeLayer(searchedLocationMarker); searchedLocationMarker = null; }
        activeSearchedLocation = null;
        searchInputEl.value = ''; // Clear search bar
    }

    document.querySelectorAll('li[data-id]').forEach(item => item.classList.remove('selected-haversine', 'selected-directions-start', 'selected-directions-end', 'selected-proximity-center'));
    if(clickedListItemEl) clickedListItemEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

    if (currentMode === 'kaartweergave') {
        // Clear any "committed" custom markers from other modes
        if (customHaversineMarker) { map.removeLayer(customHaversineMarker); customHaversineMarker = null; }
        if (customDirectionsStartPtMarker) { map.removeLayer(customDirectionsStartPtMarker); customDirectionsStartPtMarker = null; }
        if (customDirectionsEndPtMarker) { map.removeLayer(customDirectionsEndPtMarker); customDirectionsEndPtMarker = null; }
        if (customProximityCenterPtMarker) { map.removeLayer(customProximityCenterPtMarker); customProximityCenterPtMarker = null; }
        haversineSelectedLocation = null; directionsStartLocation = null; directionsEndLocation = null; proximityCenterLocation = null;
        clearMapDrawings();

        if (isDigipunt(clickedLocData) && !showDigipunten) { showDigipuntenToggle.checked = true; showDigipunten = true; }
        if (isExternalPartner(clickedLocData) && !showExternalPartners) { showExternalPartnersToggle.checked = true; showExternalPartners = true; }
        if (isStation(clickedLocData) && !showStations) { showStationsToggle.checked = true; showStations = true; }

        updateMarkerVisibility(); // Apply visibility changes from potential checkbox toggles
        resetAllPopupContent();   // Ensure all popups have fresh kaartweergave content

        // Specifically open the popup for the clicked item
        const marker = getMarkerForLocation(clickedLocData); // Use getMarkerForLocation for safety, though for list clicks it's mapMarkers[id]
        if (marker && map.hasLayer(marker)) {
            marker.openPopup();
            map.setView(clickedLocData.location, Math.max(map.getZoom(), 14));
        }
        // Note: The final updatePopupVisibility call below will handle showAllPopups logic.
        // If showAllPopups is false, we need to ensure this single popup isn't closed by it.
        // This is handled by the conditional call to updatePopupVisibility at the end.

    } else if (currentMode === 'haversine') {
        if (customHaversineMarker) { map.removeLayer(customHaversineMarker); customHaversineMarker = null; }
        if (customDirectionsStartPtMarker) { map.removeLayer(customDirectionsStartPtMarker); customDirectionsStartPtMarker = null; }
        if (customDirectionsEndPtMarker) { map.removeLayer(customDirectionsEndPtMarker); customDirectionsEndPtMarker = null; }
        if (customProximityCenterPtMarker) { map.removeLayer(customProximityCenterPtMarker); customProximityCenterPtMarker = null; }
        directionsStartLocation = null; directionsEndLocation = null; proximityCenterLocation = null;

        const isCurrentlySelected = haversineSelectedLocation && haversineSelectedLocation.id === clickedLocData.id;
        clearMapDrawings();

        if (isCurrentlySelected) {
            haversineSelectedLocation = null;
            if(clickedListItemEl) clickedListItemEl.classList.remove('selected-haversine');
            haversineInfoDiv.style.display = 'none';
            resetAllPopupContent();
        } else {
            haversineSelectedLocation = clickedLocData;
            if (clickedListItemEl) clickedListItemEl.classList.add('selected-haversine');
            displayHaversineDistances(clickedLocData); // This calls updatePopupVisibility
        }
    } else if (currentMode === 'directions') {
        if (customHaversineMarker) { map.removeLayer(customHaversineMarker); customHaversineMarker = null; }
        if (customProximityCenterPtMarker) { map.removeLayer(customProximityCenterPtMarker); customProximityCenterPtMarker = null; }
        haversineSelectedLocation = null; proximityCenterLocation = null;

        if (!directionsStartLocation || (directionsStartLocation && directionsEndLocation)) {
            if (customDirectionsStartPtMarker) { map.removeLayer(customDirectionsStartPtMarker); customDirectionsStartPtMarker = null; }
            if (customDirectionsEndPtMarker) { map.removeLayer(customDirectionsEndPtMarker); customDirectionsEndPtMarker = null; }
            clearMapDrawings();

            directionsStartLocation = clickedLocData;
            directionsEndLocation = null;
            if (clickedListItemEl) clickedListItemEl.classList.add('selected-directions-start');

            directionsInfoDiv.style.display = 'block';
            directionsRouteSummaryEl.innerHTML = `Startpunt: <b>${clickedLocData.title}</b>.<br>Selecteer Eindpunt...`;
            resetAllPopupContent();
            const startMarker = getMarkerForLocation(clickedLocData);
            if(startMarker && map.hasLayer(startMarker)) startMarker.setPopupContent(`<b>${clickedLocData.title} (Start)</b>`).openPopup();

        } else {
            if (directionsStartLocation.id === clickedLocData.id) {
                directionsStartLocation = null;
                if (customDirectionsStartPtMarker) { map.removeLayer(customDirectionsStartPtMarker); customDirectionsStartPtMarker = null; }
                if (clickedListItemEl) clickedListItemEl.classList.remove('selected-directions-start');
                directionsInfoDiv.style.display = 'none';
                clearMapDrawings();
                resetAllPopupContent();
            } else {
                if (customDirectionsEndPtMarker) { map.removeLayer(customDirectionsEndPtMarker); customDirectionsEndPtMarker = null; }
                directionsEndLocation = clickedLocData;
                if (clickedListItemEl) clickedListItemEl.classList.add('selected-directions-end');
                if (directionsStartLocation && !directionsStartLocation.id.startsWith('custom-')) {
                     const startLi = document.querySelector(`#location-list li[data-id="${directionsStartLocation.id}"], #external-partner-list li[data-id="${directionsStartLocation.id}"], #station-list li[data-id="${directionsStartLocation.id}"]`);
                     if (startLi) startLi.classList.add('selected-directions-start');
                }
                fetchAndDrawORSRoute(directionsStartLocation, directionsEndLocation); // This calls updatePopupVisibility
            }
        }
    } else if (currentMode === 'proximity') {
        if (customProximityCenterPtMarker) { map.removeLayer(customProximityCenterPtMarker); customProximityCenterPtMarker = null; }
        if (customHaversineMarker) { map.removeLayer(customHaversineMarker); customHaversineMarker = null; }
        if (customDirectionsStartPtMarker) { map.removeLayer(customDirectionsStartPtMarker); customDirectionsStartPtMarker = null; }
        if (customDirectionsEndPtMarker) { map.removeLayer(customDirectionsEndPtMarker); customDirectionsEndPtMarker = null; }
        haversineSelectedLocation = null; directionsStartLocation = null; directionsEndLocation = null;

        const isCurrentlySelected = proximityCenterLocation && proximityCenterLocation.id === clickedLocData.id;
        clearMapDrawings();

        if (isCurrentlySelected) {
            proximityCenterLocation = null;
            if(clickedListItemEl) clickedListItemEl.classList.remove('selected-proximity-center');
            clearProximityResultsAndShape();
            proximityInfoDiv.style.display = 'none';
            resetAllPopupContent();
        } else {
            proximityCenterLocation = clickedLocData;
            if (clickedListItemEl) clickedListItemEl.classList.add('selected-proximity-center');
            proximityCenterNameEl.textContent = clickedLocData.title;
            clearProximityResultsAndShape();
            proximityInfoDiv.style.display = 'none';
            resetAllPopupContent();
            const centerMarker = getMarkerForLocation(clickedLocData);
            if(centerMarker && map.hasLayer(centerMarker)) centerMarker.setPopupContent(`<b>${clickedLocData.title}</b><br>(CENTRUMPUNT NABIJHEID)`).openPopup();
        }
    }

    // Focus map on selected item from list/map, if not in kaartweergave (where it's handled inside the block)
    // For kaartweergave, setView is already done inside its block.
    if (currentMode !== 'kaartweergave') {
        const markerToFocus = getMarkerForLocation(clickedLocData);
        if (markerToFocus && map.hasLayer(markerToFocus)) {
             map.setView(clickedLocData.location, Math.max(map.getZoom(), 14));
        } else if (clickedLocData.location) {
            map.setView(clickedLocData.location, Math.max(map.getZoom(), 14));
        }
    }

    updateMarkerVisibility(); // Ensures correct markers are generally visible

    // Conditional final popup update:
    if (currentMode === 'kaartweergave') {
        if (showAllPopupsToggle.checked) {
            // If "show all" is checked, then updatePopupVisibility will open all relevant popups.
            updatePopupVisibility();
        }
        // If "show all" is NOT checked, the single popup opened earlier in the 'kaartweergave'
        // block should remain open, and other popups should be closed.
        // updatePopupVisibility() IF CALLED would close the single one if it's not in popupsToOpenMarkers.
        // By NOT calling it here when showAllPopups is false, the single popup state is preserved.
        // Other popups would have been closed by previous calls or by updatePopupVisibility
        // when showAllPopups was turned off.
    } else {
        // For other modes, their specific functions (displayHaversine, fetchRoute, displayProximity)
        // often handle their primary popups and then call updatePopupVisibility,
        // or we rely on this final call for general consistency (like showAllPopups in other modes).
        updatePopupVisibility();
    }

    updateInstructions();
}


    document.addEventListener('DOMContentLoaded', function () {
        map = L.map('map-container').setView([51.053, 3.725], 12);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> & Routing/Isochrones via <a href="https://openrouteservice.org/">OpenRouteService</a> & Zoeken via <a href="https://pelias.io/">Pelias</a>'
        }).addTo(map);

        allLocations.sort((a, b) => a.title.localeCompare(b.title));

        allLocations.forEach((loc) => {
            let marker;
            let listItem = document.createElement('li');
            listItem.textContent = loc.title;
            listItem.setAttribute('data-id', loc.id);

            let iconToUse = digipuntIcon; // Default
            if (isStation(loc)) {
                iconToUse = stationEmojiIcon;
                stationListEl.appendChild(listItem); listItem.classList.add('station-item');
            } else if (isExternalPartner(loc)) {
                 iconToUse = externalPartnerEmojiIcon;
                 externalPartnerListEl.appendChild(listItem); listItem.classList.add('location-item'); // Assuming 'location-item' is general enough
            } else { // isDigipunt
                locationListEl.appendChild(listItem); listItem.classList.add('location-item');
            }
            marker = L.marker(loc.location, { icon: iconToUse });
            marker.bindPopup(getPopupContent(loc), { autoClose: false, closeOnClick: true, className: 'custom-popup' }); // autoClose: false good for showAllPopups
            mapMarkers[loc.id] = marker;

            listItem.addEventListener('click', () => handleLocationClick(loc, listItem));
            marker.on('click', (e) => { // Handle clicks on predefined map markers
                 L.DomEvent.stopPropagation(e); // Prevent map click if icon is clicked
                 // Find corresponding list item to trigger its click handler for consistent state updates
                 const liForMarker = document.querySelector(`#location-list li[data-id="${loc.id}"], #external-partner-list li[data-id="${loc.id}"], #station-list li[data-id="${loc.id}"]`);
                 if (liForMarker) {
                      liForMarker.click(); // Simulate list item click
                 } else {
                     // Fallback if no list item (should not happen for predefined locations)
                     handleLocationClick(loc, null); // Pass null for listItemEl
                 }
            });
        });

        showAllPopupsToggle.checked = showAllPopups;
        showDigipuntenToggle.checked = showDigipunten;
        showExternalPartnersToggle.checked = showExternalPartners;
        showStationsToggle.checked = showStations;

        appTitleEl.textContent = 'Haversine'; // Initial title - may need adjustment
        profileSelectorDiv.style.display = 'none';
        proximityControlsSection.style.display = 'none';
        currentProfileDisplayEl.textContent = getProfileDisplayName(selectedRouteProfile);

        proximityRadiusInput.value = proximityRadiusKm;
        proximityTimeInput.value = proximityTimeMinutes;
        proximityProfileSelect.value = proximityTravelProfile;
        proximityTypeSelect.value = proximityAnalysisType;
        if (proximityAnalysisType === 'distance') {
            proximityDistanceControlsGroup.style.display = 'block';
            proximityTimeControlsGroup.style.display = 'none';
        } else {
            proximityDistanceControlsGroup.style.display = 'none';
            proximityTimeControlsGroup.style.display = 'block';
        }

        // Initial UI setup
        resetAllPopupContent(); // Set initial popup contents
        updateInstructions();   // Set initial instructions
        updateMarkerVisibility(); // Show/hide markers based on default filters
        updatePopupVisibility();  // Manage popups (e.g., if showAllPopups is true initially)


        modeRadioButtons.forEach(radio => radio.addEventListener('change', handleModeChange));
        document.querySelectorAll('input[name="profile"]').forEach(radio => radio.addEventListener('change', handleProfileChange));
        resetButton.addEventListener('click', clearSelectionsAndUI);

        showDigipuntenToggle.addEventListener('change', function() { showDigipunten = this.checked; handleLocationFilterChange(); });
        showExternalPartnersToggle.addEventListener('change', function() { showExternalPartners = this.checked; handleLocationFilterChange(); });
        showStationsToggle.addEventListener('change', function() { showStations = this.checked; handleLocationFilterChange(); });
        showAllPopupsToggle.addEventListener('change', function() { showAllPopups = this.checked; updatePopupVisibility(); });

        toggleMapClickModeButton.addEventListener('click', toggleMapClickSelectionMode);
        toggleInstructionsBtn.addEventListener('click', function() {
            const isHidden = instructionsEl.style.display === 'none' || instructionsEl.style.display === '';
            instructionsEl.style.display = isHidden ? 'block' : 'none';
            this.textContent = isHidden ? ' 💡' : '💡'; // Optional: change button text
        });

        proximityTypeSelect.addEventListener('change', (e) => {
            proximityAnalysisType = e.target.value;
            if (proximityAnalysisType === 'distance') {
                proximityDistanceControlsGroup.style.display = 'block';
                proximityTimeControlsGroup.style.display = 'none';
            } else {
                proximityDistanceControlsGroup.style.display = 'none';
                proximityTimeControlsGroup.style.display = 'block';
            }
        });
        runProximityAnalysisButton.addEventListener('click', performProximityAnalysis);


        map.on('click', function(e) {
            if (isMapClickModeActive) {
                const { lat, lng } = e.latlng;
                const title = `Kaartselectie (${lat.toFixed(4)}, ${lng.toFixed(4)})`;
                processCustomLocationSelection(title, [lng, lat], "mapclick");
                toggleMapClickSelectionMode(); // Automatically exit map click mode after selection
            }
        });

        searchInputEl.addEventListener('input', (event) => {
            if (isMapClickModeActive && event.target.value.length > 0) { // If user types while in map click mode
                toggleMapClickSelectionMode(); // Exit map click mode
            }
            debouncedFetchSuggestions(event.target.value);
        });
         searchInputEl.addEventListener('focus', () => {
             if (isMapClickModeActive) toggleMapClickSelectionMode(); // Exit map click mode if search is focused
         });

        // Prevent search results from disappearing too quickly on blur
        let searchResultsListFocused = false;
        searchResultsListEl.addEventListener('mouseenter', () => searchResultsListFocused = true);
        searchResultsListEl.addEventListener('mouseleave', () => searchResultsListFocused = false);

        searchInputEl.addEventListener('blur', () => {
            setTimeout(() => {
                // Only clear if focus hasn't moved to the results list itself (e.g. by clicking a scrollbar)
                // and ensure the active element is not within the search results list (e.g. a clicked item).
                if (!searchResultsListFocused && !searchResultsListEl.contains(document.activeElement)) {
                     searchResultsListEl.innerHTML = '';
                }
            }, 200); // Increased delay slightly
        });
    });
</script>
</body>
</html>
